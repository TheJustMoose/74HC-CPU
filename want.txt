заказать платы:
5 MUX8:1 v3 (нужно 3)
5 Regs
10 (5*2) RegCnt (не паяются старые) + трафарет*2! - панелизировать? (нужно 10, 8 + 2 на стек)
5 ROM ?
5 Toggle - панелизировать? (нужно 4? 6?)

10 (5*2?) STACK-16bit - панелизировать? (нужно 8)
5 ADD команда, с дополнительным выходом HCF (проверить, может уже есть?)

заказать платы:
5 MUX4:1 v3
5 переходник 273
10 RegLED
10 MUL

заказать платы:
RegLed3
CMP
INV-B
INV-BB
RAM?

хочется:
Flags
JMPS
RAM
ROM
Addr Counter
Osc

MUL, ALU - похожи на stripboard


Сделано прям сейчас в железе:

 0 1 2 3 4 5 6 7 8 9 A B C D E F
      4 + 2 + 2 + 8
|  COP  |DST|SRC|  MAYBE CONST  | N
---------------------------------
|  ADD  |DST|SRC|       -       | 0  // вообще-то здесь есть 8 свободных бит, которые можно спокойно потратить для модификации команды
| ADDC  |DST|SRC|       -       | 1  // и сделать из неё INC, DEC, ...
|  AND  |DST|SRC|       -       | 2
|   OR  |DST|SRC|       -       | 3
|  XOR  |DST|SRC|       -       | 4
|  MOV  |DST|SRC|       -       | 5
|  UNO  |DST|TYP|       -       | 6  // INV SWAP LSR LSRC
|  MUL  |DST|SRC|       -       | 7
|  LDI  |DST| - |     CONST     | 8  // SRC здесь не используются, но можно переключать константу между: 1, 2, CONST, 0xFF
|   LD  |DST|EXT|     CONST     | 9  // EXT может переключать входы сумматора RAM по принципу: ADDR = R3:R2*EXT[0] + CONST; EXT[1] переключает на пару R1:R0
|   IN  |DST|PRT|       -       | A  // PRT - номер порта, откуда будем вводить данные
|  OUT  |PRT|SRC|       -       | B  // PRT - номер порта, куда будем выводить данные
|   ST  |SRC|EXT|     CONST     | C  // SRC стоит на месте DST, т.к. для команды есть отдельный мультиплексор, подключенный к шине OUT
| CTRL  | FLAGS |       -       | D  // CLRF STOP [INC SP ; DEC SP]
|  CMP  |DST|SRC|       -       | E
| BRANC |  TYPE |  8 BIT ADDR   | F  // CALL, JMP, RET, JZ, JL, JNE, JG, -, JE, JC, JNZ, JNC
                                     // переход сейчас только относительный и только в пределах +-127 команд
                                     // но есть несколько свободных команд, можно сделать FARJMP, а лучше JMP по абсолютному адресу
план:
доделать подключение RAM, сделать переключение между парами регистров и зануление регистров в мультиплексорах
сделать плату портов
реализовать команды IN + OUT
поменять ROM на 16 бит, ибо задолбало
нарисовать/протравить плату ROM
врезать в АЛУ инвертор и шинник перед бинарными командами,
 (последний нужен для того, чтобы при подключении константы не случилось КЗ)
+добавить на АЛУ разъёмов, чтобы два раза не разбирать
+сделать новую плату==стрипбоард MUL, закрепить под АЛУ!
реализовать команду INC
поменять MUX4:1 на новые, с шинными формирователями
переделать счётчик адреса, использовать старые MUX4:1
(хотя лучше нарисовать новые, узкие)
реализовать команду FARCALL (пусть будет AFCALL - absolute far call)
стек для CALL!!
переделать мультиплексор, который делает из DST+SRC указатель,
 кажется, можно посто отрезАть младший бит, и пускать на мультиплексоры захардкоженные 0/1

Можно добиться минимальной кровью
(так как ADDI, ANDI до сих пор нет, лишние регистры не помешают):
                      4   +  3 + 1 + 3  +    5    = 16
                   0 1 2 3 4 5 6 7 8 9 A B C D E F
                  |  COP  | DST |*| SRC | MB CONST| N  // бит * может работать по разному, для разных команд
 cmd structure    ---------------------------------    // bits: d - DST, s - SRC, C - UseCF, I - InvSRC, F - ForceCF, Z - ZeroSRC, v - const
0000ddd0sss---ZI  |   AND | DST |0| SRC |  -  |Z|I| 0  //       p - PORT, P - REGISTER PAIR, o - OFFSET, typ - TYPE, a - ADDR
0000ddd1vvvvvvvv  |  ANDI | DST |1|  8 BIT CONST  | 0  // константа вместо регистра (нужен дополнительный шинный формирователь на шину SRC, но он конфликтует с битом I)
0001ddd0sss---ZI  |    OR | DST |0| SRC |  -  |Z|I| 1  // не понятно, нужны ли биты I+Z для команд AND/OR/XOR
0001ddd1vvvvvvvv  |   ORI | DST |1|  8 BIT CONST  | 1  // константа вместо регистра
0010ddd0sss---ZI  |   XOR | DST |0| SRC |  -  |Z|I| 2
0010ddd1vvvvvvvv  |  XORI | DST |1|  8 BIT CONST  | 2
0011ddd0sss---ZI  |   MOV | DST |0| SRC |  -  |Z|I| 3  // с MOV, кстати, тоже будет работать, поэтому можно сделать R1 := INV(R0), или типа того
0011ddd1vvvvvvvv  |  MOVI | DST |1|  8 BIT CONST  | 3
0100ddd0sss---ZI  |   MUL | DST |0| SRC |  -  |Z|I| 4  // а команда MUL в сочетании с ZeroSRC позволит занулить сразу два регистра
0100ddd1vvvvvvvv  |  MULI | DST |1|  8 BIT CONST  | 4  // константа

0101ddd-typ-----  |   UNO | DST |-| TYP |  -      | 7  // INV SWAP LSR LSRC (кстати, теперь здесь есть ещё 4 свободных слота!)

0110ddd0sss--FZI  |   ADD | DST |C| SRC | - |F|Z|I| 5  // есть 4 бита, для модификации команды UseCF(C), InvSRC(I), ForceCF(F), ZeroSRC(Z)
0111ddd1vvvvvvvv  |  ADDI | DST |C|  8 BIT CONST  | 6  // чтобы сделать из неё INC, INCC, DEC, DECC, SUB, SUBC
1000dddZPooooooo  |    LD | DST |Z|P| 7BIT OFFSET | 8  // Z может переключать входы сумматора RAM по принципу: ADDR = R7:R6*E + CONST, P переключает на пару R5:R4
1001sss-pppppppp  |    IN | DST |-|  7 BIT PORT |I| 9  // PORT - номер порта, откуда будем вводить данные, I - проинвертировать вводимое значение
1010sss-pppppppp  |   OUT | SRC |-|  8 BIT PORT   | A  // смотри ниже... (придётся использовать тот же мультиплексор, что и для памяти)
1011sssZPooooooo  |    ST | SRC |Z|P| 7BIT OFFSET | B  // SRC стоит на месте DST, т.к. для команды ST есть отдельный мультиплексор, подключенный к шине OUT
1100flg---------  |  CTRL |FLAGS|-|          -    | C  // CLRF STOP/DBG SETCF
1101dddCsss-----  |   CMP | DST |C| SRC |    -    | D  // окей, а здесь есть свободные биты для организации CMPC
1110dddCvvvvvvvv  |  CMPI | DST |C|  8 BIT CONST  | E
1111typeaaaaaaaa  | BRANC |  TYPE |  8 BIT ADDR   | F  // CALL, JMP, RET, JZ, JL, JNE, JG, RETI?, JE, JC, JNZ, JNC [AJMP, FJMP]
                   0 1 2 3 4 5 6 7 8 9 A B C D E F     // окей, есть 8 бит.... хорошо, но мало. нужен FARJMP, и опять таки ABSJUMP :((

план:
перенести биты SRC туда же, где биты CONST
заменить мультиплексоры на MUX8:1
протестировать на той системе команд, что есть ;)

перенести подключение константы с шины OUT на шину SRC
нарисовать/протравить новую плату декодера команд
снова всё соединить
переделать RAM, добавить на эту же плату ROM, развернуть разъём OFFSET
прикрутить UART
добавить банк памяти

кстати, при переезде на команду MUL1, в качестве счётчика адреса, можно сделать MUL1 + MUL1 + MUX + мелкая логика = 16 бит адрес + FARJMP
то есть, можно будет воткнуть несколько "сервисных" процедур в верхние адреса, с шагом по 256 байт, и с переходом по абсолютным адресам

можно попробовать сделать так:
    4   +  3  +1+  3  +   5   = 16
 0 1 2 3 4 5 6 7 8 9 A B C D E F
------------------------------------
|  ADD  | DST |0| SRC |-|Z|z|I|-| 00  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
| ADDC  | DST |0| SRC |-|Z|z|I|F| 01  // F - установить CF в 1, z/Z - занулить младший/старший нибл SRC, I - инвертировать SRC
|  AND  | DST |0| SRC |-|Z|z|I|-| 02  // примеры: INC => ADD Rx, x ; F=1 + Z=1 + z=1
|   OR  | DST |0| SRC |-|Z|z|I|-| 03  //          MOV R1, 60h ; ADD R1, R2 ; Z=1 => отковырять младший нибл и сделать из него символ
|  XOR  | DST |0| SRC |-|Z|z|I|-| 04  //          XOR R1, R1 ; z=1 => занулить только старший нибл
|  MOV  | DST |0| SRC |-|Z|z|I|-| 05  //          AND R1, R2 ; I=1 => проинвертировать R2 и сделать AND с R1
|  MUL  | DST |0| SRC |-|Z|z|I|-| 06  //          ADD R1, R2 ; I=1 => проинвертировать R2 и сделать ADD с R1 => SUB R1, R2!
|  UNO  | DST |0|TYP|-|-|Z|z|I|F| 07  // INV SWAP LSR LSRC ; флаг CF=1 даст для LSR единичку в старшем бите, остальные флаги меняют SRC, который здесь не используется
| *LPM* | DST |0|EXT|D|U|OFFSET4| 08  // ROM/RAM ADDR = PTR + OFFSET4;  OFFSET4 - максимальное смещение +-8 байт
|   LD  | DST |0|EXT|D|U|OFFSET4| 09  // EXT переключает PTR на пару R13:R12 (X) / R15:R14 (Y) / SP (4 пары регистров, одна пока не используется)
|   IN  | DST |0|PORT |-|-|-|I|-| 0A  // I/i инвертировать ли порт при IN                                              // PUSH Rx => ST [SP], Rx   ; DEC SP
|  OUT  |PORT |0| SRC |-|O|o|X|x| 0B  // XOR-ить ли порт (X, x) (мл.нибл) при OUT и какой нибл (O, o) вообще выводить  // POP  Rx => LD Rx, [SP-1] ; INC SP
|   ST  | SRC |0|EXT|D|U|OFFSET4| 0C  // U => UP - автоинкремент регистра после операции, D => DOWN - автодекремент регистра
| CTRL  |    FLAGS    |    -    | 0D  // CLRF, STOP, [INC SP, DEC SP]
| BRNCH |TYPE |0|   8 bit ADDR  | 0E  // CALL, JMP, RET, JZ, JL, JNE, JG, NOP - переход в +-127 команды, значение прибавляется к текущему счётчику команд
|  CMP  | DST |0| SRC |-|  -    | 0F  //   JE, JC, JNZ, JNC, --, --, STP, AFCALL - Absolute Far Call - 8 bit ADDR кладём в старшие биты и ничего не добавляем
                                      //   0    1    2    3   4   5    6   7


Вариант от 11.12.2023:
Убрал LDI и CTRL. CLRF(CTRL) теперь реализован в виде порта ввода-вывода.
Добавил LPM и CMPC.
Сделал адреса порта пяти битным.

Легенда (действия с SRC перед подачей в АЛУ):
Z - занулить старший ниббл
z - занулить младший ниббл
I - проинвертировать старший ниббл
i - проинвертировать младший ниббл
C - переключить шину SRC на константу
    (в этом режиме отключается зануление и инверсия за ненадобностью)

F - установить флаг CF в 1 на время выполнения операции
O - вывести старший ниббл в порт
o - вывести младший ниббл в порт
X - поксорить порт со старшим нибблом
x - поксорить порт со младшим нибблом
P - дополнительные биты номера порта
X, Y - регистры-указатели  // LD R1, X
+X - автоинкремент после операции (XI? YI?)
-X - автодекремент после операции (XD? YD?)
X + 1 - прочитать/записать ячейку памяти по указателю X + 1
+X + 1 - то же самое, но указатель после операции проинкрементировать
TYP - тип унарной операции: -INV-, SWAP, LSR, LSRC, [SHUFFLE, MIRROR]
EXT - какую пару регистров использовать в качестве указателя (R7:R6, R5:R4, SP, 0)
BTYPE - тип команды перехода (или команды управления)

    4   +  3  +1+  3  +   5   = 16
 0 1 2 3 4 5 6 7 8 9 A B C D E F
------------------------------------
|   ADD | DST |C| SRC |-|Z|z|I|i| 00 0000 // ADDI R0, 1         // INC R0;
|  ADDC | DST |C| SRC |-|Z|z|I|i| 01 0001 // ADDC R1, 1 (+F=1)  // INCC R1;    // кажется, бит F теперь не нужен, потому что можно использовать константу
|   AND | DST |C| SRC |-|Z|z|I|i| 02 0010 // ANDI R2, 0x0F
|    OR | DST |C| SRC |-|Z|z|I|i| 03 0011 // ORI R3, 2
|   XOR | DST |C| SRC |-|Z|z|I|i| 04 0100 // XORI R4, 4
|   MOV | DST |C| SRC |*|Z|z|I|i| 05 0101 // MOVI R5, 5     // LDI R5, 5       // * - можно использовать, чтобы пихать адрес в SPL/SPH
|   MUL | DST |C| SRC |-|Z|z|I|i| 06 0110 // MULI R6, 10    // R7:R6 := R6*10
|   UNO | DST |0|TYP|-|F|Z|z|I|i| 07 0111 // теперь, когда инвертор есть на шине SRC можно выкинуть команду INV и заменить её... на SHUFFLE? MIRROR?
|   LPM | DST |0|EXT|D|U|OFFSET4| 08 1000 // LPM R0, [+X]   // LPM R1, [X+1]   // LPM R1, [-X-1]
|    LD | DST |0|EXT|D|U|OFFSET4| 09 1001 // LD R1, [-Y]    // LD R3, [+SP-1] ; POP R3
|    IN | DST |  PORT   |-|-|I|i| 0A 1010 // IN R2, PIN1    // IN R2, ~PIN1 ; инвертировать порт перед чтением
---------------7-8-9-A-B------------      всё что ниже - не модифицирует регистры
|   OUT | SRC |  PORT   |O|o|X|x| 0B 1011 // OUT PORT0, R2  // XOUT PORT0, R2
|    ST | SRC |0|EXT|D|U|OFFSET4| 0C 1100 // ST [Y], R2     // ST [+X], R2     // ST [Y+2], R2   // ST [-SP], R2 ; PUSH R2
|   CMP | DST |C| SRC |-|   -   | 0D 1101 // CMPI R3, 10    // CMP  R0, R2
|  CMPC | DST |C| SRC |-|   -   | 0E 1110 // CMPCI R4, 10   // CMPC R1, R3
| BRNCH | BTYPE |   8 bit ADDR  | 0F 1111 // CALL, JMP, RET,  JZ,   JL,  JNE,  JE,    JG - переход в +-127 команды, значение прибавляется к текущему счётчику команд
                                          //   JC, JNZ, JNC, JHC, JNHC, STOP, AFCALL, NOP  // AFCALL - Absolute Far Call - 8 bit ADDR кладём в старшие биты и ничего не добавляем
                                          //    0    1    2    3     4     5    6     7    // NOP - хорошо бы чтоб имел код 0xFF, это позволит думать, что не прошитая память заполнена NOP-ами

Oops! Что будет читать LPM, если ROM у меня 16 битный??? Хотя, это похоже на команду MUL
И не вкрутить ли сюда тупо Unicode? Всё равно старший байт пропадает.
Нужен ли бит D в команде LPM? Это ж не RAM, зачем её читать в обратном порядке?
Oops! Придумать что-то с pushf/popf

// Бит 7 кода операции (C) указывает на то, что нужно переключить шину SRC на константу (CONST)
// Его нужно использовать, если команда из первой половины списка, или если код команды 0D|0E
// Можно сделать OUT PORT0, CONST.
----------------------------------------------------------------------------------------------
PORT0 - порт вывода 0 (бит 0 подключен к LCD.RS, бит 7 к LCD LED, биты 1+2 к линиям опроса кнопок)
PORT1 - порт вывода 1 (R-2R?)
PORT2 - LCD Data, запись происходит по фронту OUT2
PORT3 - порт для управления регистром флагов (что хорошо, т.к. теперь регистры отдельно, порты отдельно)
           0     1    2    3    4     5    6    7
        | HCF | CF | ZF | LF | ~EQ | GF | BF | DBG | - чтение
  CLRF     0     0    0    0    0     0    0    0    - а при записи единицы переключать только DBG, а по остальным делать CLRF
 SETCF     0     1    0    0    0     0    0    0   == OUT PORT3, 2
(HCF - Half Carry Flag - перенос из 3 в 4 разряды сумматора... как раз у меня два 4 битных сумматора есть)
(BF - Bank Flag, DBG - не менее гипотетический флаг отладки)

под эти 4 порта можно сделать отдельную плату:
PORT4 - порт вывода 4
PORT5 - DDR == функции пинов PORT4, ввод или вывод (почти как в AVR)
PORT6 - порт вывода 6
PORT7 - DDR == функции пинов PORT6, ввод или вывод (почти как в AVR)
----------------------------------------------------------------------------------------------
PORT8-15 - можно отдать под UART
----------------------------------------------------------------------------------------------
PORT16-23 - таймеры?
PORT24-31 - MMU?
----------------------------------------------------------------------------------------------
PIN0 - порт ввода 0, подключен к кнопкам (сканируется сразу весь ряд)
PIN1 - порт ввода 1
PIN2 - порт ввода 2
PIN3 - чтение регистра флагов
PIN4 - придумать уже что-то типа MSW (Machine State Word), или 3 бита указателя стека вызовов, для отладки не помешает
PIN6 - читаем, что там положили на входные пины, если конечно они вообще входные (см.PORT7)
----------------------------------------------------------------------------------------------
PIN8-15 - можно отдать под UART
----------------------------------------------------------------------------------------------
PIN16-23 - счётчик тактов (2 байта? 4?)
PIN24-31
----------------------------------------------------------------------------------------------

Туду:
придумать некий универсальный интерфейс для шилдов, чтоб можно было подключать то LCD, то светодиодные матрицы...
а если прикрутить компаратор, то можно ставить эксперименты с АЦП последовательного приближения (ЦАП то типа есть)
добавить на плату Toggle на выход 74HC125, тогда получится как у AVR
(но нужен ещё сам регистр, который будет хранить направление)
переделать RAM на IS61C5128AS
отключать часть инструкций (OUT) для некоторых задач
сделать process ID, и переключение задач по таймеру
(ну и таймер сделать *ROFL*)

.   .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . . . .
     _______         _______
____/       \_______/       \_____
  Read    Latch   Latch     Inc
   Cmd     Cmd   Result    Addr

Подходящий LCD:
http://www.lcdwiki.com/3.5inch_Arduino_Display-UNO
по идее, он тоже ляжет на PORT0+1, вместо 1602
https://aliexpress.ru/item/1005006221009489.html?sku_id=12000036339571446
https://aliexpress.ru/item/1005005326045644.html?sku_id=12000036725418502
или такой:
http://www.lcdwiki.com/3.95inch_Arduino_Display-UNO
https://aliexpress.ru/item/1005004626417855.html?sku_id=12000029884013288
https://aliexpress.ru/item/1005006183069747.html?sku_id=12000036171849215
https://aliexpress.ru/item/1005006183069747.html?sku_id=12000036171849219
16BIT RGB 65K color display, 480x320 resolution == 300KByte O_O
480 / 8 = 60 chars
320 / 8 = 40 chars
96 x 61 mm
0.2mm pixel size
1.6mm char size O_O
3.5mm на обычном LCD мониторе Оо
итого: надо рисовать по 4 пикселя сразу (2x2), иначе буквы не разглядеть
тогда памяти надо в 4 раза меньше: 300/4 == 75KByte
а если цвет сделать 8 битным, а не 16, то нужно 37КБ видео-памяти (а у меня весь ROM на 32КБ, вроде)
а если делать текстовый режим, то памяти нужно 30*20 == 600 байт (и ещё столько же на цвета)
(у CGA есть режим 40x25, что можно получить, если шрифт будет 12x12, плюс 20 пикселей лишних)
(возможно стоит взять шрифт 12x16, например из u8g2, получится 40x20 символов)

пары регистров (LD, SP, LPM):
 R1:R0
 R3:R2
 R5:R4 | X   // можно использовать как арифметические, так и как указатель X (EXT==0)
 R7:R6 | Y   // можно использовать как арифметические, так и как указатель Y (EXT==1)
       | SP  // стек, это отдельный регистр, но подключается на место R7:R6 в командах PUSH/POP (EXT==2)
       | 0   // просто ноль, можно использовать для чтения глобальных переменных из начала RAM (EXT==3)
             // и при этом не портить регистры-указатели X и Y

SP, в отличии от всех остальных регистров, не нужно читать и писать...
Его нужно только инкрементировать/декрементировать и слать в RAM.
С другой стороны, есть готовый мультиплексор и лень городить ещё один.
А что если когда-нибудь приспичит писать в стек не 0xFFFF, а что-то другое?

16 бит мультиплексор адреса ROM
MUX LOW_ADDR HI_ADDR  Meaning
00     ADDR +1/+CONST (CMD | JL...) - только здесь работает сумматор
01   CONST      00h   AFCALL/IRQ  | команда перехода содержит только 8 бит адреса, прерывание тоже
10     DST      SRC   LPM         | поэтому приходится запихивать его либо в старший байт, либо в младший
11    ADDR     ADDR   RET         | адрес возврата, он действительно 16 бит

Именование:
OUT - просто OUT (причём тактировать можно, например, LCD по сигналу C1)
XOUT - OUT + XOR - и назвать это TOGGLE (TGL? TGGL? TOG? TOGL?) - а здесь тактировать не получиться, потому что по C0 будет записан результат XOR
OUTL - вывод младшего ниббла
OUTH - вывод старшего ниббла
TOGLL - переключение битов младшего ниббла
TOGLH - переключение битов старшего ниббла
ADD R0, ~R1 - проинвертировать регистр R1 (но как указать, что нибл старший?)

Хочу!
Написать ассемблер, мини Си, досыпать классов.
Упихать туда BASIC
Поиграть с gLCD ;)
Сделать миниатюрную клавиатуру под qwerty.
Сделать звук из R-2R!

ТуДу:
процессор пока в работе, а компилятор написать уже хочется...
 поэтому надо написать эмулятор, а в нём уже писать компилятор!
+перерисовать MUX8 в виде 100x150
сделать платы стека на 16 бит (сейчас на 8) и перенести светодиоды на бок
нарисовать плату регистров, снова, 100x150
поправить регистры на 193, заказать трафареты
переделать регистры с 593 на 273, добавить пин сброса, сделать чтобы пины совпадали с 193
или просто сделать все регистры на 193? их проще в SOIC-е разводить
нарезать уже плату ROM из stripboard
проверить везде именование C0, C1, C2 и сделать как-нибудь одинаково

Сколько нужно битов для трёхадресного процессора?
16 + 3 = 19. Вот только тогда константа не влезет.

| ADDC  | DST |0| SRC |F|Z|z|I|i| 01  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
INC  == ADDI  Rx, 1  ; всё ок  // просто прибавляем единичку
INC  == ADDC  Rx, N  ; F+Z+z   // складываем пару регистров, но второй регистр полностью зануляем, а единица приходит через CF
INC  == ADDCI Rx, 0  ; F       // складываем с нулём, единица приходит через CF
INCC == ADDCI Rx, 0  ;         // добавляем ноль, учитываем перенос
DEC  == ADDI  Rx, FF ;         // FF и есть -1
DEC  == ADD   Rx, N  ; Z+z+I   // ну, типа костыль, да
DECC == ADDCI Rx, FF
; X -= Y
SUB  == ADDC  Rx, Ry ; FIi     // чтобы поменять знак у Ry нужно сделать инвертирование и прибавление единички
SUBC == ADDC  RX, RY ; Ii      // а здесь надо просто проинвертировать старший байт, а единица не нужна, есть CF

MOVI R1, '2'
ANDI R1, 0x0F ; окей, '2' -> 2

INV  == MOV   Rx, Ry ; Ii      // инвертируем биты перед копированием
NEG  == MOV   Rx, Ry ; FIi     // инвертируем и добавляем единичку

LOW  == MOV   Rx, Ry ; Z       // старший нибл зануляем, младший копируем
HIGH == MOV   Rx, Ry ; z       // младший нибл зануляем, старший копируем


альтернатива:
|  ADD  | DST |0| SRC |C|F|Z|I|i| 00  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
                       C - UseCF, F - ForceCF, Z - zero src, I - Inv src high nibble, i - Inv low nibble
INC == ADD Rx, 0 ; C+F+Z

R1:R0
01 01 +
FF FF =
01 00 == DEC
DEC  R0  ; иначе случайно выставленный бит переноса отнимет лишнюю единицу
DECC R1  ; иначе не дойдёт займ от предыдущего байта

ТуДу: переделать (*ROFL*) существующую команду OUT так, чтобы строб вырабатывался не путём дёргания отдельного бита, а из сигнала C1
это позволит упростить подключение LCD

адреса:
относительные - хорошо подойдут для jl, je, lpm (перейди на 10 байт назад, возьми данные на 10 байт вперёд)
абсолютные - подойдут для call, и  lpm (функция вызывается из нескольких мест и каждый раз считать смещение не ок,
                                        да и строки можно положить в захардкоженные адреса)

так как старший бит команды свободен, можно легко добавить переключение на константу по этому биту:
|  ADDI | DST |1|     CONST     | 10  // сложение с константой
| ADDCI | DST |1|     CONST     | 11  // сложение с константой
|  ANDI | DST |1|     CONST     | 12  // AND с константой
|   ORI | DST |1|     CONST     | 13  // OR с константой
|  XORI | DST |1|     CONST     | 14  // XOR с константой
|  MOVI | DST |1|     CONST     | 15  // MOV с константой (нужен ли тогда LDI?)
|  MULI | DST |1|     CONST     | 16  // MUL с константой (в данном случае прикол в том, что результат всё равно ляжет в ДВА регистра)
                                      // MUL r0, r7 ; r1:r0 := r0*r7 ; нужна ли при этом константа? хз
                                      // MULI r0, 3 ; r1:r0 := r0*3  ; вообще константа пригодилась бы
| -LPMI-| DST |1|      ADDR     | 18  // НАФИГ, ПУСТЬ ЛУЧШЕ БУДЕТ АВТОИНКРЕМЕНТ АДРЕСА
|  CMPI | DST |1|     CONST     | 1E  // CMP с константой
 0 1 2 3 4 5 6 7 8 9 A B C D E F

туду:
+сделать так, чтобы умножитель записывал и старшую половину результата
*переделать регистры на 74HC193 с тем, чтобы у них случился автоинкремент/декремент*
спаять мультиплексоры MUX8:1
поменять мультиплексоры на MUX8:1
перекинуть проводки SRC на другие биты
скоммутировать битики зануления и инверсии
добавить мультиплексор для переключения SRC на константу
добавить мультиплексор 257, т.к. теперь три бита SRC, а не два
  или убавить мультиплексор 257, т.к. можно просто отключать младший бит, а старшие оставить как есть
убрать шинник подключения константы к OUT

+переделать INV-B и добавить на него шинник?
протравить новый инвертор INV-B с двумя входами
не забыть, что я хотел переставить местами команды BRANCH/CMP и UNO/MUL

подумать, не сделать ли стек в виде просто 74HC161/193 (или как там называется двоичный реверсивный счётчик)
типа так:
ADDR = PTR + OFFSET4;
EXT[2:1] переключает PTR на пару R1:R0 / R3:R2 / R5:R4 / R7:R6
EXT[0] - переключает "банк", с тем, чтобы SP жил сам по себе и не мешал другим регистрам
                      банк 0       0   /   Z   /   Y   /   X
                      банк 1       0   /   ?   /   BP  /   SP
В принципе, можно не городить отдельный большой MUX8:1, а прям рядом с RAM поставить MUX2:1,
один его вход подключить к шинам SRC/DST, как сейчас, а второй подвести к SP.
Можно даже сделать отдельную плату из 4 регистров SP и 4 мультиплексоров 2:1.

Какие операции могут случиться:
strcpy(a, b)
do {
 R0 := [X]
 X++
 [Y] := R0
 Y++
} while (R0)

print(str)
BP := SP
[BP+0] := str addr low
[BP+1] := str addr high
call print

чтение глобальной переменной:
X = addr  ; запись в два регистра R7:R6
R0 := [X]

сортировка:
SORT:
R0 := [X]
R1 := [X+1]
CMP R0, R1
JL SKIP
[X] := R1   ; SWAP
[X+1] := R0
SKIP:
INC  R6
INCC R7
JMP SORT

 Z  I  SRC
 ----------
 0  0  SRC
 0  1  !SRC
 1  0  0
 1  1  FF

CALL/RET:
MUX4:1
00 - IP := IP + 1/CONST  // STEP/JMP/CALL
01 - IP := [SP++]        // RET  (здесь другой SP)
10 - IP := CONST << 8    // AFCALL | IRQ ADDR == 0 (у мультиплексора есть вход EN, который обнуляет всё)
11 - IP := R3:R2         // LPM ADDR (в принципе, ничто не мешает взять X/Y с выхода мультиплексоров регистров и кинуть сюда)


CTRL имеет 6 свободных бит
0 - CLRF
1 - ? можно вкрутить инкремент/декремент пар регистров
или установку триггера, который всегда будет делать инкремент после операции чтения/записи

или даже вот так:
 0 1 2 3 4 5 6 7 8 9 A B C D E F
      6     + 2 + 2 = 10
|     ADD   |DST|SRC|     -     | 0
|    ADDC   |DST|SRC|     -     | 1
|     AND   |DST|SRC|     -     | 2
|      OR   |DST|SRC|     -     | 3
|     XOR   |DST|SRC|     -     | 4
|     MOV   |DST|SRC|     -     | 5
|     MUL   |DST|SRC|     -     | 6
|     UNO   |DST|TYP|     -     | 7
|     LDI   |DST|       CONST   | 8   // 6 + 2 + 8 = 16
|      LD   |DST|SRC|   CONST   | ?   // УПС! было смещение от 0 до 255, стало до 63 ;)
// недостающие биты можно размазать на несколько команд: LD (оба значения), LDO (только смещение), LDA (только адрес R3:R2)
|      LD   |DST|       CONST   | 9   // R3:R2 + CONST
|     LDA   |DST|         -     | A   // R3:R2
|     LDO   |DST|       CONST   | B   // CONST

|      IN   |DST|SRC|     -     | C
|     OUT   |DST|SRC|     -     | D
|      ST   |DST|SRC|   CONST   | E/F/10

|    CTRL   |  FLAGS|     -     | 11   // теперь не нужна, можно сделать CLRF
|     CMP   |DST|SRC|     -     | 12
|    CMPC   |DST|SRC|     -     | 13

и теперь можно чего-нибудь добавить:
|     SUB   |DST|SRC|     -     | 14
|     SBC   |DST|SRC|     -     | 15
|    ADDI   |DST|      CONST    | 16
|   ADDCI   |DST|      CONST    | 17
|    ANDI   |DST|      CONST    | 18
|     ORI   |DST|      CONST    | 19
|    XORI   |DST|      CONST    | 1A
|    MOVI   |DST|      CONST    | 1B
|    MULI   |DST|      CONST    | 1C
|    SUBI   |DST|      CONST    | 1D
|    SBCI   |DST|      CONST    | 1E
|    CMPI   |DST|      CONST    | 1F
|   CMPCI   |DST|      CONST    | 20

|     INC   |DST|         -     | 21
|    INCC   |DST|         -     | 22
|     DEC   |DST|         -     | 23
|    DECC   |DST|         -     | 24

|     LPM   |DST|      ADDR     | 25
|    LPMA   |DST|         -     | 26  // читаем из R3:R2, например

остались не заняты: 26, 27, 28, 29, 2A

|  BRANCH   | TYPE  |  OFFSET   | ?   // а вот с переходами стало как-то совсем грустно :(

но можно сделать так:
|    JMP    |       OFFSET      | 2B  // 6 + 10
|   CALL    |       OFFSET      | 2C  // 6 + 10
|    RET    |          -        | 2D  // 6 + 10
|     JL    |       OFFSET      | 2E  // 6 + 10
|     JE    |       OFFSET      | 2F  // 6 + 10
|     JG    |       OFFSET      | 30  // 6 + 10
|    JNE    |       OFFSET      | 3A  // 6 + 10
|     JC    |       OFFSET      | 3B  // 6 + 10
|    JNC    |       OFFSET      | 3C  // 6 + 10
|     JZ    |       OFFSET      | 3D  // 6 + 10
|    JNZ    |       OFFSET      | 3E  // 6 + 10
|    NOP    |       OFFSET      | 3F  // 6 + 10

туду: переупорядочить как-то команды, чтобы минимизировать логику

------------------------------------------------------------------
6 бит -> 64 команды -> 0..63 -> 00..3F
         4*16

собираем в кучу:

CMD     CONST
TYPE  REQUIRED - этот же бит входит в состав кода операции, но пишу я его отдельно, просто чтобы видеть значение бита
 ||      ||
 \/      \/
// команды на 0 (нужен дешифратор на 8)
// используют CONST как надо, переключают мультиплексор
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP Const // младший бит тоже является кодом операции,
|00   ADD 0|DST||SRC|     -     | 00  00 000 0     // но также указывает на необходимость использования константы
|00  ADDI 1|DST||      CONST    | 01  00 000 1
|00  ADDC 0|DST||SRC|     -     | 02  00 001 0
|00 ADDCI 1|DST||      CONST    | 03  00 001 1
|00   SUB 0|DST||SRC|     -     | 04  00 010 0
|00  SUBI 1|DST||      CONST    | 05  00 010 1
|00  SUBC 0|DST||SRC|     -     | 06  00 011 0
|00 SUBCI 1|DST||      CONST    | 07  00 011 1

|00   AND 0|DST||SRC|     -     | 08  00 100 0
|00  ANDI 1|DST||      CONST    | 09  00 100 1
|00    OR 0|DST||SRC|     -     | 0A  00 101 0
|00   ORI 1|DST||      CONST    | 0B  00 101 1
|00   XOR 0|DST||SRC|     -     | 0C  00 110 0
|00  XORI 1|DST||      CONST    | 0D  00 110 1
|00   MOV 0|DST||SRC|     -     | 0E  00 111 0
|00  MOVI 1|DST||      CONST    | 0F  00 111 1

// команды на 1 (нужен дешифратор на 16)
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP
|01   MUL 0|DST||SRC|     -     | 10  01 000 0  // чудес на свете не бывает, и результат всё равно ляжет в два регистра
                                                // поэтому нет смысла экономить на спичках, и умножать на константу
|01   LPM 1|DST||         -     | 11  01 000 1  // читаем память программ по адресу, лежащему в [R3:R2]
|01   UNO 0|DST||TYP|     -     | 12  01 001 0

// на данный момент эти константы подключены непосредственно к RAM
|01    LD 1|DST||     OFFSET    | 13  01 001 1  // LD Rx, [OFFSET] (load by offset) - чтение глобальных переменных (256 байт)
|01   LDA 0|DST||         -     | 14  01 010 0  // LD Rx, [R3:R2] (load by ptr) - чтение по указателю, а-ля *ptr
|01   LDO 1|DST||     OFFSET    | 15  01 010 1  // LD Rx, [R3:R2 + OFFSET] (load by ptr+offset) - чтение со смещением, а-ля *(ptr+1)

|01    IN 0|DST||SRC|     -     | 16  01 011 0

// для команды ST выделен отдельный мультиплексор, подключенный к шине OUT
// он получает биты S0:S1 из несколько непривычного места, а именно оттуда,
// откуда обычно достаются биты DST
// содержимое мультиплексора SRC, подаваемое на одноимённую шину, лучше бы занулить
|01    ST 1|S01||     OFFSET    | 17  01 011 1  // ST [CONST], Rx
|01   STA 0|S01||         -     | 18  01 100 0  // ST [R3:R2], Rx
|01   STO 1|S01||     OFFSET    | 19  01 100 1  // ST [R3:R2 + CONST], Rx

|01  CTRL 0|TYP||         -     | 1A  01 101 0  // всё та же старая команда CTRL, за которой прячется CLRF, STOP, ...
|01   OUT 1|DST||SRC|     -     | 1B  01 101 1  // просто вывод регистра в порт
                                                // гипотетически, можно выводить в порт именно константу
                                                // всё равно логика переключения шины SRC между регистром и константой "уже есть"
|01   CMP 0|DST||SRC|     -     | 1C  01 110 0
|01  CMPI 1|DST||      CONST    | 1D  01 110 1
|01  CMPC 0|DST||SRC|     -     | 1E  01 111 0
|01 CMPCI 1|DST||      CONST    | 1F  01 111 1

// команды на 2
// 6 + 10 бит (переход на +-512 байт)
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP
|10   JMP 0|        OFFSET      | 20  10 000 0
|10  CALL 1|        OFFSET      | 21  10 000 1
|10   RET 0|           -        | 22  10 001 0
|10    JL 1|        OFFSET      | 23  10 001 1
|10    JE 0|        OFFSET      | 24  10 010 0
|10    JG 1|        OFFSET      | 25  10 010 1
|10   JNE 0|        OFFSET      | 26  10 011 0
|10    JC 1|        OFFSET      | 27  10 011 1
|10   JNC 0|        OFFSET      | 28  10 100 0
|10    JZ 1|        OFFSET      | 29  10 100 1
|10   JNZ 0|        OFFSET      | 2A  10 101 0
|10   NOP 1|        OFFSET      | 2B  10 101 1
|10  FJMP 0|        OFFSET      | 2C  // FAR JUMP == JUMP TO OFFSET*16 (или на 64?)
|10 FCALL 1|        OFFSET      | 2D  10 110 0

// команды на 3 == LPM
// кода операции нет, команда выполяется при любых значениях, лишь бы первые два бита были 00 ;)
 01 2 3 4 5 6 7  8 9 A B C D E F        CT COP
    x x x x      x x x x x x x x                // <-- 12 бит
|11   ADDR |DST|       ADDR     | 3x  11 xxx x  // читаем по фиксированному адресу, всего 4096 адресов
                                                // память 16 битная Оо

структура команды:
тип  команда константа
2 бит  3 бит   1 бит
если (CMD TYPE == 0)
  выбираем команду ADD и логику для неё
если (CMD TYPE == 1)
  включаем дешифратор команд, который выбирает AND, MUL, ...
если команда == LPM
  переключаем генератор в режим трёх тактов
  подключаем к OUT мультиплексор с константой, прочитанной LPM
если (CMD TYPE == 2)
  подключаем много разной логики управления RAM, CLRF, OUT, CMP
если (CMD TYPE == 3)
  включаем логику переходов

карта памяти:
FFFF
  16550
FFF8
FFF7
  ROM
8000
7FFF
  RAM
0000

для 16550 доступ по указателю и смещению, наверное не нужен, достаточно кидать константу -1 == FFFF, -2 == FFFE...
на плату RAM добавляем ещё и ROM, а также отрезаем доступ по верхним 16-ти адресам
шины ADDR и CONST меняем местами (или всё же нет)

делаем отдельную плату, на которой располагаем 16550 и PCF8584 (I2C)
на этой плате наоборот делаем доступ по последним 16-ти адресам, и не делаем сумматора адресов

если ужаться до 32 команд, то на код операции уйдёт ровно 5 бит, и тогда можно перейти на 8 регистров,
а вся команда ляжет в 16 бит вместе с 8 бит константой

Любое увеличение команд/регистров свыше 16/4 приводит к тому, что я выхожу за пределы одного байта.
А это приводит к тому, что константу фиг прочитаешь.
Хотя...
Если просто взять 16 бит память, то константа остаётся внутри одного слова.
Хотя без константы часть битов будет пустой.

| 0 1 2 3 4 5 6 7 || 8 9 A B C D E F |
| -  COP  - D S T || S R C           |
| -  COP  - D S T ||    C O N S T    | - и каким мне боком теперь указывать, что здесь константа, а не SRC??
И в итоге всё равно мне нужно уместиться в 32 команды.

переделать проц, сделать так, чтобы:
шина OUT была 16 битной
это позволит более менее универсально сделать не только операцию MUL
но так же делать "сложные" команды а-я "сравнить два числа и переставить местами, если одно больше другого"
плюс "инкремент сразу пары регистров"
плюс "загрузка целого слова в пару регистров"

А лучше переделать его так, чтобы команда выполнялась за один такт!

можно попробовать сделать хитрые банки регистров
банк 1 - для арифметических вычислений
банк 2 - для регистров указателей
при этом банк два подключить к ДРУГОМУ мультиплексору, который будет отдавать адрес в RAM
Тогда получится, что указатели доступны всегда, но чтобы сделать инкремент - надо переключить банк.
Вроде это даже не очень больно.
Зато регистров - дофига.
Упс. Чтобы это сделать понадобиться отдельный мультиплексор для адресов и дополнительные выходы между регистрами и шинниками (там, где сейчас светодиоды стоят).

Альтернатива - нафиг банки, сделать хитрые регистры - счётчики на базе 74HC193.

Ещё можно выкинуть нафиг команду INV, если поставить на шину SRC инверторы, как и планировалось, и использовать команду MOV.
Но команду MOV тоже можно выкинуть, для этого можно использовать битик ZeroSRC (точнее, ZeroDST) и просто дёргать команду ... ADD!!

Чтобы не писать свой собственный код можно попробовать сделать эмулятор 8051 и брать прошивки от него.

Бесит:
слишком длинный код
 потому что нет ADDI и т.п.
  сделать уже ADDI, ANDI, ...
слишком неудобный CALL
 потому что нет абсолютных адресов
  сделать уже большой MUX16 и прикрутить туда всё, что нужно
нельзя проинвертировать бит порта, потому что есть только OUT PORT, REG
 то есть, сначала нужно положить что-то в регистр, потом вывести
  протравить уже плату Toggle, которую я уже нарисовал
ещё и регистр нужен, так как нельзя прочитать что-то из выходного порта
слишком мало регистров
 прикрутить уже MUX8:1 и спаять ещё регистров
отсутствие LPM вынуждает задавать строки посимвольно через LDI
 прикрутить к тому самому MUX16 какой-нибудь регистр, и брать из него указатель
