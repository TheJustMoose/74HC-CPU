заказать платы:
5 MUX8:1 v3 (нужно 3)
5 Regs
10 (5*2) RegCnt (не паяются старые) + трафарет*2! - панелизировать? (нужно 10, 8 + 2 на стек)
5 ROM ?
5 Toggle - панелизировать? (нужно 4? 6?)

10 (5*2?) STACK-16bit - панелизировать? (нужно 8)
5 ADD команда, с дополнительным выходом HCF (проверить, может уже есть?)

заказать платы:
5 MUX4:1 v3
5 переходник 273
10 RegLED
10 MUL

заказать платы:
RegLed3
CMP
INV-B
INV-BB
RAM?

хочется:
Flags
JMPS
RAM
ROM
Addr Counter
Osc

MUL, ALU, Regs - похожи на stripboard


Сделано прям сейчас в железе:

 0 1 2 3 4 5 6 7 8 9 A B C D E F
      4 + 2 + 2 + 8
|  COP  |DST|SRC|  MAYBE CONST  | N
---------------------------------
|  ADD  |DST|SRC|       -       | 0  // вообще-то здесь есть 8 свободных бит, которые можно спокойно потратить для модификации команды
| ADDC  |DST|SRC|       -       | 1  // и сделать из неё INC, DEC, ...
|  AND  |DST|SRC|       -       | 2
|   OR  |DST|SRC|       -       | 3
|  XOR  |DST|SRC|       -       | 4
|  MOV  |DST|SRC|       -       | 5
|  UNO  |DST|TYP|       -       | 6  // INV SWAP LSR LSRC
|  MUL  |DST|SRC|       -       | 7
|  LDI  |DST| - |     CONST     | 8  // SRC здесь не используются, но можно переключать константу между: 1, 2, CONST, 0xFF (если константу не прошивать, то там и так будет FF)
|   LD  |DST|EXT|     CONST     | 9  // EXT может переключать входы сумматора RAM по принципу: ADDR = R3:R2*EXT[0] + CONST; EXT[1] переключает на пару R1:R0
|   IN  |DST|PRT|       -       | A  // PRT - номер порта, откуда будем вводить данные
|  OUT  |PRT|SRC|       -       | B  // PRT - номер порта, куда будем выводить данные
|   ST  |SRC|EXT|     CONST     | C  // SRC стоит на месте DST, т.к. для команды есть отдельный мультиплексор, подключенный к шине OUT
| CTRL  | FLAGS |       -       | D  // CLRF STOP [INC SP ; DEC SP]
|  CMP  |DST|SRC|       -       | E
| BRANC |  TYPE |  8 BIT ADDR   | F  // CALL, JMP, RET, JZ, JL, JNE, JG, -, JE, JC, JNZ, JNC
                                     // переход сейчас только относительный и только в пределах +-127 команд
                                     // но есть несколько свободных команд, можно сделать FARJMP, а лучше JMP по абсолютному адресу
план:
доделать подключение RAM, сделать переключение между парами регистров и зануление регистров в мультиплексорах
сделать плату портов
реализовать команды IN + OUT
поменять ROM на 16 бит, ибо задолбало
нарисовать/протравить плату ROM
врезать в АЛУ инвертор и шинник перед бинарными командами,
 (последний нужен для того, чтобы при подключении константы не случилось КЗ)
+добавить на АЛУ разъёмов, чтобы два раза не разбирать
+сделать новую плату==стрипбоард MUL, закрепить под АЛУ!
реализовать команду INC
поменять MUX4:1 на новые, с шинными формирователями
переделать счётчик адреса, использовать старые MUX4:1
(хотя лучше нарисовать новые, узкие)
реализовать команду FARCALL (пусть будет AFCALL - absolute far call)
стек для CALL!!
переделать мультиплексор, который делает из DST+SRC указатель,
 кажется, можно посто отрезАть младший бит, и пускать на мультиплексоры захардкоженные 0/1

план:
перенести биты SRC туда же, где биты CONST
заменить мультиплексоры на MUX8:1
протестировать на той системе команд, что есть ;)

перенести подключение константы с шины OUT на шину SRC
нарисовать/протравить новую плату декодера команд
снова всё соединить
переделать RAM, добавить на эту же плату ROM, развернуть разъём OFFSET
прикрутить UART
добавить банк памяти

кстати, при переезде на команду MUL1, в качестве счётчика адреса, можно сделать MUL1 + MUL1 + MUX + мелкая логика = 16 бит адрес + FARJMP
то есть, можно будет воткнуть несколько "сервисных" процедур в верхние адреса, с шагом по 256 байт, и с переходом по абсолютным адресам


Вариант от 11.12.2023:
Убрал LDI и CTRL. CLRF(CTRL) теперь реализован в виде порта ввода-вывода.
Добавил LPM и CMPC.
Унёс команду MOV ниже, так как она не должна менять регистр флагов.
Сделал адрес порта пяти битным.

Легенда (действия с SRC перед подачей в АЛУ):
Z - занулить старший ниббл
z - занулить младший ниббл
I - проинвертировать старший ниббл
i - проинвертировать младший ниббл
Z+I приведёт к тому, что в ниббле будут единицы, поэтому:
H - заединичить старший ниббл
h - заединичить младший ниббл
C - переключить шину SRC на константу
    (в этом режиме отключается зануление и инверсия за ненадобностью)

F - установить флаг CF в 1 на время выполнения операции
O - вывести старший ниббл в порт
o - вывести младший ниббл в порт
X - поксорить порт со старшим нибблом
x - поксорить порт со младшим нибблом
P - дополнительные биты номера порта
X, Y - регистры-указатели  // LD R1, X
+X - автоинкремент после операции (XI? YI?)
-X - автодекремент после операции (XD? YD?)
X + 1 - прочитать/записать ячейку памяти по указателю X + 1
IX + 1 - то же самое, но указатель после операции проинкрементировать
TYP - тип унарной операции: -INV-, SWAP, LSR, LSRC, [SHUFFLE, MIRROR]
EXT - какую пару регистров использовать в качестве указателя (R7:R6, R5:R4, SP, 0)
BTYPE - тип команды перехода (или команды управления)

|---------------------------------------------|
|   HIGH BYTE   |    LOW BYTE   |  HIGH BYTE  |
|   4   +  3 + 1 + 3  +    5    = 16  (again) |
|0 1 2 3 4 5 6 7 8 9 A B C D E F|        Flags|
|---------------------------------------------|
|   ADD | DST |C| SRC |-|Z|z|I|i| 00 0000  *  | ADDI  R0, 1    // INC R0;
|  ADDC | DST |C| SRC |F|Z|z|I|i| 01 0001  *  | ADDCI R1, 0    // INCC R1;    // бит F нужен для команд -INC-, -DEC-, SUB, -INV-, NEG
|   AND | DST |C| SRC |-|Z|z|I|i| 02 0010  *  | ANDI R2, 0x0F  // здесь есть свободный бит, и вместо F туда можно положить S[WAP] или S[HIFT]
|    OR | DST |C| SRC |-|Z|z|I|i| 03 0011  *  | ORI R3, 2      // в любом случае, сдвиг старшего нибла на место младшего кажется полезным
|   XOR | DST |C| SRC |-|Z|z|I|i| 04 0100  *  | XORI R4, 4     // кстати, в этом случае можно ещё и от команды SWAP избавиться
|   MUL | DST |C| SRC |-|Z|z|I|i| 05 0101  *  | MULI R6, 10    // R7:R6 := R6*10
|   UNO | DST |0|-|TYP|F|-|-|-|-| 06 0110  *  | унарные команды не используют операнд SRC, поэтому нельзя использовать инверторы и отдельные нибблы
|   MOV | DST |C| SRC |*|Z|z|I|i| 07 0111  -  | MOVI R5, 5     // LDI R5, 5       // * - можно использовать, чтобы пихать адрес в SPL/SPH (правда, только из других регистров)
|   LPM | DST |W|EXT|D|U|OFFSET4| 08 1000  -  | LPM R0, [IX]   // LPM R1, [X+1]   // LPM R1, [DX-1]  // W - читать слово (1) или байт (0)
|    LD | DST |0|EXT|D|U|OFFSET4| 09 1001  -  | LD R1, [-Y]    // LD R3, [+SP-1] ; POP R3
|    IN | DST |  PORT   |-|-|I|i| 0A 1010  -  | IN R2, PIN1    // IN R2, ~PIN1 ; инвертировать порт перед чтением
|-------------|7-8-9-A-B|-------|-------------| всё что ниже - не модифицирует регистры
|   OUT | SRC |  PORT   |O|o|X|x| 0B 1011  -  | OUT PORT0, R2  // XOUT PORT0, R2
|    ST | SRC |0|EXT|D|U|OFFSET4| 0C 1100  -  | ST [Y], R2     // ST [IX], R2     // ST [Y+2], R2   // ST [-SP], R2 ; PUSH R2
|   CMP | DST |C| SRC |-|   -   | 0D 1101  +  | CMPI R3, 10    // CMP  R0, R2
|  CMPC | DST |C| SRC |-|   -   | 0E 1110  +  | CMPCI R4, 10   // CMPC R1, R3
| BRNCH |  CALL | 8 bit OFFSET  | 0F 1111 0000| переход в +-127 команды, значение прибавляется к текущему счётчику команд
| BRNCH |   JMP | 8 bit OFFSET  | 0F 1111 0001| <- COP low nibble
| BRNCH |   RET | 8 bit +STACK  | 0F 1111 0010| на сколько байт переместить указатель стека данных, дабы пропустить запушенные параметры
| BRNCH |    JZ | 8 bit OFFSET  | 0F 1111 0011| условные переходы
| BRNCH |    JL | 8 bit OFFSET  | 0F 1111 0100|
| BRNCH |   JNE | 8 bit OFFSET  | 0F 1111 0101|
| BRNCH |    JE | 8 bit OFFSET  | 0F 1111 0110|
| BRNCH |    JG | 8 bit OFFSET  | 0F 1111 0111|
| BRNCH |    JC | 8 bit OFFSET  | 0F 1111 1000|
| BRNCH |   JNZ | 8 bit OFFSET  | 0F 1111 1001|
| BRNCH |   JNC | 8 bit OFFSET  | 0F 1111 1010| выкинуть инструкции, что реально не будут использоваться
| BRNCH |   JHC | 8 bit OFFSET  | 0F 1111 1011| вкрутить что-то вроде NJMP offset (и делать реальный переход на offset*16, к примеру)
| BRNCH |  JNHC | 8 bit OFFSET  | 0F 1111 1100|
| BRNCH |  STOP |   0000 0000   | 0F 1111 1101| отладочный стоп, чтобы можно было смотреть глазами регистры (и есть 8 бит на фантазию)
| BRNCH |AFCALL | Hi 8 bit ADDR | 0F 1111 1110| Absolute Far Call - 8 bit ADDR кладём в старшие биты и ничего не добавляем к младшим
| BRNCH |   NOP |   1111 1111   | 0F 1111 1111| NOP - хорошо бы чтоб имел код 0xFF, это позволит думать, что не прошитая память заполнена NOP-ами
|---------------------------------------------|
* - меняем CF, HCF, ZF (результат сложения)
+ - меняем LF, EQ, GF (результат сравнения)

Oops! Что будет читать LPM, если ROM у меня 16 битный??? Хотя, это похоже на команду MUL
И не вкрутить ли сюда тупо Unicode? Всё равно старший байт пропадает.
Нужен ли бит D в команде LPM? Это ж не RAM, зачем её читать в обратном порядке?
Oops! Придумать что-то с pushf/popf
Флаги нужно писать только для первой половины команд, иначе POP R1 испортит флаги.
Собственно, LD, ST, PUSH, POP, IN, OUT, BRNCH, LPM флагов не меняют. MOV, кстати, тоже.
Кстати, у LD/ST есть один свободный бит, гипотетически, можно его использовать для адресации дополнительных 64КБ памяти.
 (однако возникает проблема, как тогда обрабатывать инкремент адреса 0xFFFF)
А ещё нужен RETI, но его я потерял. Он должен разрешать прерывания. То есть, менять флаг I, который тоже потерял.
И нужен RET 6, чтобы снимать со стека 6 параметров, к примеру, иначе надо делать 6 раз POP.
Зануление можно делать не только на шине SRC, но и на DST, так как все мультиплексоры одинаковые.
Однако лишних битов в системе команд под это не осталось :(
Нужно сделать двухпортовые регистры, выделить их в отдельный банк, который будет хранить указатели.

// Бит 7 кода операции (C) указывает на то, что нужно переключить шину SRC на константу (CONST)
// Его нужно использовать, если команда из первой половины списка, или если код команды 0D|0E
// Можно сделать OUT PORT0, CONST.
----------------------------------------------------------------------------------------------
PORT0 - порт вывода 0 (бит 0 подключен к LCD.RS, бит 7 к LCD LED, биты 1+2 к линиям опроса кнопок)
PORT1 - порт вывода 1 (R-2R?)
PORT2 - LCD Data, запись происходит по фронту OUT2
PORT3 - порт для управления регистром флагов (что хорошо, т.к. теперь регистры отдельно, порты отдельно)
           0     1    2    3    4     5    6    7
        | HCF | CF | ZF | LF | ~EQ | GF | BF | DBG | - чтение
  CLRF     0     0    0    0    0     0    0    0    - а при записи единицы переключать только DBG, а по остальным делать CLRF
 SETCF     0     1    0    0    0     0    0    0   == OUT PORT3, 2
(HCF - Half Carry Flag - перенос из 3 в 4 разряды сумматора... как раз у меня два 4 битных сумматора есть)
(BF - Bank Flag, DBG - не менее гипотетический флаг отладки)

под эти 4 порта можно сделать отдельную плату:
PORT4 - порт вывода 4
PORT5 - DDR == функции пинов PORT4, ввод или вывод (почти как в AVR)
PORT6 - порт вывода 6
PORT7 - DDR == функции пинов PORT6, ввод или вывод (почти как в AVR)
----------------------------------------------------------------------------------------------
PORT8-15 - можно отдать под UART
----------------------------------------------------------------------------------------------
PORT16-23 - таймеры?
PORT24-31 - MMU? I2C?
----------------------------------------------------------------------------------------------
PIN0 - порт ввода 0, подключен к кнопкам (сканируется сразу весь ряд)
PIN1 - порт ввода 1
PIN2 - порт ввода 2
PIN3 - чтение регистра флагов
PIN4 - придумать уже что-то типа MSW (Machine State Word), или 3 бита указателя стека вызовов, для отладки не помешает
PIN6 - читаем, что там положили на входные пины, если конечно они вообще входные (см.PORT7)
----------------------------------------------------------------------------------------------
PIN8-15 - можно отдать под UART
----------------------------------------------------------------------------------------------
PIN16-23 - счётчик тактов (2 байта? 4?)
PIN24-31
----------------------------------------------------------------------------------------------

Девайсы:
порты
таймеры
LCD/gLCD
UART
R-2R DAC
I2C
ADC?


Туду:
команда mov Y, Hello не работает, потому что регистры восьмибитные, а адрес - 16 бит
и макросы работают только для замены одной команды на другую
 надо что-то придумать... например возможно делить адрес на старшую/младшую половины
придумать некий универсальный интерфейс для шилдов, чтоб можно было подключать то LCD, то светодиодные матрицы...
а если прикрутить компаратор, то можно ставить эксперименты с АЦП последовательного приближения (ЦАП то типа есть)
добавить на плату Toggle на выход 74HC125, тогда получится как у AVR
(но нужен ещё сам регистр, который будет хранить направление)
переделать RAM на IS61C5128AS
отключать часть инструкций (OUT) для некоторых задач
сделать process ID, и переключение задач по таймеру
(ну и таймер сделать *ROFL*)

.   .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . . . .
     _______         _______
____/       \_______/       \_____
  Read    Latch   Latch     Inc
   Cmd     Cmd   Result    Addr

Подходящий LCD:
http://www.lcdwiki.com/3.5inch_Arduino_Display-UNO
по идее, он тоже ляжет на PORT0+1, вместо 1602
https://aliexpress.ru/item/1005006221009489.html?sku_id=12000036339571446
https://aliexpress.ru/item/1005005326045644.html?sku_id=12000036725418502
или такой:
http://www.lcdwiki.com/3.95inch_Arduino_Display-UNO
https://aliexpress.ru/item/1005004626417855.html?sku_id=12000029884013288
https://aliexpress.ru/item/1005006183069747.html?sku_id=12000036171849215
https://aliexpress.ru/item/1005006183069747.html?sku_id=12000036171849219
16BIT RGB 65K color display, 480x320 resolution == 300KByte O_O
480 / 8 = 60 chars
320 / 8 = 40 chars
96 x 61 mm
0.2mm pixel size
1.6mm char size O_O
3.5mm на обычном LCD мониторе Оо
итого: надо рисовать по 4 пикселя сразу (2x2), иначе буквы не разглядеть
тогда памяти надо в 4 раза меньше: 300/4 == 75KByte
а если цвет сделать 8 битным, а не 16, то нужно 37КБ видео-памяти (а у меня весь ROM на 32КБ, вроде)
а если делать текстовый режим, то памяти нужно 30*20 == 600 байт (и ещё столько же на цвета)
(у CGA есть режим 40x25, что можно получить, если шрифт будет 12x12, плюс 20 пикселей лишних)
(возможно стоит взять шрифт 12x16, например из u8g2, получится 40x20 символов)

пары регистров (LD, SP, LPM):
 R1:R0
 R3:R2
 R5:R4 | X   // можно использовать как арифметические, так и как указатель X (EXT==0)
 R7:R6 | Y   // можно использовать как арифметические, так и как указатель Y (EXT==1)
       | SP  // стек, это отдельный регистр, но подключается на место R7:R6 в командах PUSH/POP (EXT==2)
       | 0   // просто ноль, можно использовать для чтения глобальных переменных из начала RAM (EXT==3)
             // и при этом не портить регистры-указатели X и Y

SP, в отличии от всех остальных регистров, не нужно читать и писать...
Его нужно только инкрементировать/декрементировать и слать в RAM.
С другой стороны, есть готовый мультиплексор и лень городить ещё один.
А что если когда-нибудь приспичит писать в стек не 0xFFFF, а что-то другое?

16 бит мультиплексор адреса ROM
MUX LOW_ADDR HI_ADDR  Meaning
00     ADDR +1/+CONST (CMD | JL...) - только здесь работает сумматор
01   CONST      00h   AFCALL/IRQ  | команда перехода содержит только 8 бит адреса, прерывание тоже
10     DST      SRC   LPM         | поэтому приходится запихивать его либо в старший байт, либо в младший
11    ADDR     ADDR   RET         | адрес возврата, он действительно 16 бит

CALL/RET:
MUX4:1
00 - IP := IP + 1/CONST  // STEP/JMP/CALL
01 - IP := CONST << 8    // AFCALL | IRQ ADDR == 0 (у мультиплексора есть вход EN, который обнуляет всё)
10 - IP := R3:R2         // LPM ADDR (в принципе, ничто не мешает взять X/Y с выхода мультиплексоров регистров и кинуть сюда)
11 - IP := [SP++]        // RET  (здесь другой SP)


Именование:
OUT - просто OUT (причём тактировать можно, например, LCD по сигналу C1)
XOUT - OUT + XOR - и назвать это TOGGLE (TGL? TGGL? TOG? TOGL?) - а здесь тактировать не получиться, потому что по C0 будет записан результат XOR
OUTL - вывод младшего ниббла
OUTH - вывод старшего ниббла
TOGLL - переключение битов младшего ниббла
TOGLH - переключение битов старшего ниббла
ADD R0, ~R1 - проинвертировать регистр R1 (но как указать, что нибл старший?)
ADDI можно не писать, т.к. из записи ADD R0, 10 и так понятно, что второй операнд не регистр
AND R0, R1.L
AND R0, ~R1

Хочу!
Написать ассемблер, мини Си, досыпать классов.
Упихать туда BASIC
Поиграть с gLCD ;)
Сделать миниатюрную клавиатуру под qwerty.
Сделать звук из R-2R!
Прикрутить sd карту, файловую систему взять у elmchan
Совместить команду OUT и JMP *ROFL*

ТуДу:
пока регистры и мультиплексоры делаются в Китае можно:
сделать ROM в виде stripboard
набить плату Ports & LCD
набить плату RAM & ROM
набить плату MUX 16 bit
написать POST, который будет тестировать команды
спаять генератор на монтажке, можно вместе с конечным автоматом
проверить скорость *ROFL*
нарисовать схему управления автоинкрементом указателей
и вообще освежить все схемы
нарисовать новый декодер команд
нарисовать новую схему переходов

процессор пока в работе, а компилятор написать уже хочется...
 поэтому надо написать эмулятор, а в нём уже писать компилятор!
+перерисовать MUX8 в виде 100x150
+нарисовать плату регистров, снова, 100x150
сделать платы стека на 16 бит (сейчас на 8) и перенести светодиоды на бок
поправить регистры на 193, заказать трафареты
переделать регистры с 593 на 273, добавить пин сброса, сделать чтобы пины совпадали с 193
или просто сделать все регистры на 193? их проще в SOIC-е разводить
проверить везде именование C0, C1, C2 и сделать как-нибудь одинаково
кажется, нужно отключить изменение флагов для LD/ST, иначе не будет работать POP flags

| ADDC  | DST |0| SRC |F|Z|z|I|i| 01  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
INC  == ADDI  Rx, 1  ; всё ок  // просто прибавляем единичку
INC  == ADDC  Rx, N  ; F+Z+z   // складываем пару регистров, но второй регистр полностью зануляем, а единица приходит через CF
INC  == ADDCI Rx, 0  ; F       // складываем с нулём, единица приходит через CF
INCC == ADDCI Rx, 0  ;         // добавляем ноль, учитываем перенос
DEC  == ADDI  Rx, FF ;         // FF и есть -1
DEC  == ADD   Rx, N  ; Z+z+I   // ну, типа костыль, да
DECC == ADDCI Rx, FF
; X -= Y
SUB  == ADDC  Rx, Ry ; FIi     // чтобы поменять знак у Ry нужно сделать инвертирование и прибавление единички
SUBC == ADDC  RX, RY ; Ii      // а здесь надо просто проинвертировать старший байт, а единица не нужна, есть CF

MOVI R1, '2'
ANDI R1, 0x0F ; окей, '2' -> 2

INV  == MOV   Rx, Ry ; Ii      // инвертируем биты перед копированием
NEG  == MOV   Rx, Ry ; FIi     // инвертируем и добавляем единичку

LOW  == MOV   Rx, Ry.L ; Z     // старший нибл зануляем, младший копируем
HIGH == MOV   Rx, Ry.H ; z     // младший нибл зануляем, старший копируем

PUSH == ST    [DX], Rx         // пишем в стек регистр, выполняем постдекремент
POP  == LD    Rx, [IX-1]       // читаем из стека регистр (X-1), выполняем постинкремент
                               // обычно при чтении стека делается инкремент, а потом чтение
                               // но у меня инкремент/декремент всегда идёт после команды, поэтому нужно сделать X-1

|  MULI | DST |1|     CONST     | 16  // MUL с константой (в данном случае прикол в том, что результат всё равно ляжет в ДВА регистра)
                                      // MUL r0, r7 ; r1:r0 := r0*r7 ; нужна ли при этом константа? хз
                                      // MULI r0, 3 ; r1:r0 := r0*3  ; вообще константа пригодилась бы

ADD R0, R1
ADD R0, R1.H
ADD R0, R1.L
ADD R0, ~R1       ; проинвертировать весь R1
ADD R0, ~H(R1)
ADD R0, ~L(R1)
ADD R0, IL(R1)
ADD R0, ~L(R1.H)  ; младшую часть инвертируем, старшую берём
                  ; так как сначала стоят мультиплексоры, а потом инверторы, младшая часть будет равна 0xFF
ADD R0, ~R1.H     ; берём старшую часть (зануляем младшую), инвертируем всё, что получилось

LD R1, [X]        ; R1 = *X
LD R1, [IX]       ; R1 = *X++
LD R1, [DX]       ; R1 = *X--
LD R1, [IX + 5]   ; R1 = *(X++ + 5)
LD R1, [0]        ; R1 = *(0)
LD R1, [15]       ; R1 = *(15)

LPM R2, [X]       ; R1 = *ROM_ADDR  // лучше бы этот адрес был относительный
...

IN R2, PIN1
IN R2, ~L(PIN1)   ; проинвертировать младший нибл порта и всё что получилось положить в регистр

m1:
ADD R1, R2
CMP R1, 10
JL m1

JMP -10   ; скакануть на 10 команд (?) назад
CALL 10   ; вызвать функцию, которая лежит на 10 команд вперёд отсюда
AFCALL 10 ; вызвать функцию по абсолютному адресу 10 * 256

db a      ; байт памяти a
dw b      ; слово памяти b
или таки .db ?

.data     ; сегмент данных, просто указание, где и что лежит в RAM, без значений
.code     ; сегмент кода, просто ассемблерные команды, которые я прошью в ROM

db c[10]  ; 10 байт, массив символов
db s[] = "Hello world!"  ; то же самое, но строка == инициализированный массив

MOV X, &a ; взять адрес a и положить его в X (вообще, команды должно быть две)
MOV Y, $  ; положить в Y адрес этой команды

OUT PORT0, R0 ; порты подключены к шине SRC (?) поэтому работают .L/.H, но не работают ~L/~H

`-= ~!@#$%^&*()_+
/\|?'"

& - адрес чего-либо (вот только он 16 битный, и его надо как-то побить на части... &H и &L?)
~ - инверсия (байта?)
~L - инверсия младшего ниббла
~H - инверсия старшего ниббла
; - комментарий
"abc" - строка, юникодная (с нулём?)
'a' - символ, юникодный
.xy - директива для ассемблера
файлы фигачим в utf-8
при ассемблировании пишем в ROM в юникоде, всё равно ROM 16 битный

ИЛИ
~~ инверсия всего
~- инверсия старшего ниббла
-~ инверсия младшего ниббла

MOV R0, -~R1.L  ; положить в R0 проинвертированный младший ниббл R1, в старший положить 0
-- OUT PORT0, R0.H ; вывести в PORT0 старший ниббл R0, в младший вывести 0
      это не будет работать, т.к. в команде нет подходящих битов для выбора ниббла регистра
OUTL PORT0, R0  ; вывести в младший ниббл PORT0 младший же ниббл R0
блин... как вывести один нибл и переключить другой?
 наверное можно зафигачить префиксы, а-ля  OUT PORT0, OoXx(R1)

R1:R0
01 01 +
FF FF =
01 00 == DEC
DEC  R0  ; иначе случайно выставленный бит переноса отнимет лишнюю единицу
DECC R1  ; иначе не дойдёт займ от предыдущего байта

адреса:
относительные - хорошо подойдут для jl, je, lpm (перейди на 10 байт назад, возьми данные на 10 байт вперёд)
абсолютные - подойдут для call, и lpm (функция вызывается из нескольких мест и каждый раз считать смещение не ок,
                                        да и строки можно положить в захардкоженные адреса)

ТуДу:
+переделать (*ROFL*) существующую команду OUT так, чтобы строб вырабатывался не путём дёргания отдельного бита, а из сигнала C1
  это позволит упростить подключение LCD
+сделать так, чтобы умножитель записывал и старшую половину результата
*переделать регистры на 74HC193 с тем, чтобы у них случился автоинкремент/декремент*
спаять мультиплексоры MUX8:1
поменять мультиплексоры на MUX8:1
перекинуть проводки SRC на другие биты
скоммутировать битики зануления и инверсии
добавить мультиплексор для переключения SRC на константу
добавить мультиплексор 257, т.к. теперь три бита SRC, а не два
  или убавить мультиплексор 257, т.к. можно просто отключать младший бит, а старшие оставить как есть
убрать шинник подключения константы к OUT
попробовать добавить в ассемблер умную обработку ошибок, чтобы он подсказывал:
MOV PORT0, R0 <- error, probably you mean OUT PORT0, R0

+переделать INV-B и добавить на него шинник?
протравить новый инвертор INV-B с двумя входами
не забыть, что я хотел переставить местами команды BRANCH/CMP и UNO/MUL

В принципе, можно не городить отдельный большой MUX8:1, а прям рядом с RAM поставить MUX2:1,
один его вход подключить к шинам SRC/DST, как сейчас, а второй подвести к SP.
Можно даже сделать отдельную плату из 4 регистров SP и 4 мультиплексоров 2:1.

Какие операции могут случиться:
strcpy(a, b)
do {
 R0 := [X]
 X++
 [Y] := R0
 Y++
} while (R0)

print(str)
BP := SP
[BP+0] := str addr low
[BP+1] := str addr high
call print

чтение глобальной переменной:
X = addr  ; запись в два регистра R7:R6
R0 := [X]

сортировка:
SORT:
R0 := [X]
R1 := [X+1]
CMP R0, R1
JL SKIP
[X] := R1   ; SWAP
[X+1] := R0
SKIP:
INC  R6
INCC R7
JMP SORT

 Z  I  SRC
 ----------
 0  0  SRC
 0  1  !SRC
 1  0  0
 1  1  FF


карта памяти:
FFFF
  ROM
8000
7FFF
  RAM
0000

делаем отдельную плату, на которой располагаем 16550 и PCF8584 (I2C)
на этой плате наоборот делаем доступ по последним 16-ти адресам, и не делаем сумматора адресов

переделать проц, сделать так, чтобы:
шина OUT была 16 битной
это позволит более менее универсально сделать не только операцию MUL
но так же делать "сложные" команды а-я "сравнить два числа и переставить местами, если одно больше другого"
плюс "инкремент сразу пары регистров"
плюс "загрузка целого слова в пару регистров"

А лучше переделать его так, чтобы команда выполнялась за один такт!

*****************************************************************************************
Можно попробовать сделать хитрые банки регистров:
банк 1 - для арифметических вычислений
банк 2 - для регистров указателей
при этом банк два подключить к ДРУГОМУ мультиплексору, который будет отдавать адрес в RAM
Тогда получится, что указатели доступны всегда, инкремент можно делать через отдельную ножку (счётчики же! 74HC193!),
 но чтобы сделать ptr += 100 - надо переключить банк.
Вроде это даже не очень больно. Как минимум стек будет работать без переключения банков.
Зато регистров - дофига.
Но чтобы это сделать понадобиться отдельный мультиплексор для адресов и хитрые регистры а-ля двухпортовая память.
По одному выходу (порту) можно переключать банки (как изначально и планировалось), по другому - считывать адреса.
Упс. Если банк указателей содержит только указатели, то как складывать указатель и смещение?
Если только ADD XL, 0x100. Арифметические то регистры не доступны :(
*****************************************************************************************

Ещё можно выкинуть нафиг команду INV, если поставить на шину SRC инверторы, как и планировалось, и использовать команду MOV.
Но команду MOV тоже можно выкинуть, для этого можно использовать битик ZeroSRC (точнее, ZeroDST) и просто дёргать команду ... ADD!!

Чтобы не писать свой собственный код можно попробовать сделать эмулятор 8051 и брать прошивки от него.

Бесит:
слишком длинный код
 потому что нет ADDI и т.п.
  сделать уже ADDI, ANDI, ...
слишком неудобный CALL
 потому что нет абсолютных адресов
  сделать уже большой MUX16 и прикрутить туда всё, что нужно
нельзя проинвертировать бит порта, потому что есть только OUT PORT, REG
 то есть, сначала нужно положить что-то в регистр, потом вывести
  протравить уже плату Toggle, которую я уже нарисовал
ещё и регистр нужен, так как нельзя прочитать что-то из выходного порта
слишком мало регистров
 прикрутить уже MUX8:1 и спаять ещё регистров
отсутствие LPM вынуждает задавать строки посимвольно через LDI
 прикрутить к тому самому MUX16 какой-нибудь регистр, и брать из него указатель

Можно ли ускорить проц?
Сейчас такты выглядят так:
.   .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . . . .
     _______         _______
____/       \_______/       \_____
  Read    Latch   Latch     Inc
   Cmd     Cmd   Result    Addr


А что если сделать конвейер?
.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
     _______         _______         _______
____/       \_______/       \_______/       \_____
  Read    Latch   Latch     Inc
   Cmd     Cmd   Result    Addr
                     _______         _______
                ____/       \_______/       \_____
                  Read    Latch   Latch     Inc
                   Cmd     Cmd   Result    Addr
      чтение         выполнение
     команды 1        команды 1
                       чтение        выполнение
                      команды 2       команды 2
                                       чтение
                                      команды 3
Кажется, здесь будет один минус:
Если выполнение команды 1 состоит в том, чтобы сделать переход на другой адрес,
то чтение команды 2 делать не надо, а надо бы подождать завершения перехода.
Это слегка сбивает процесс выполнения, так как чтение откладывается на один такт.
С другой стороны, хотя команда и выполняется за два такта,
"в среднем по больнице" на выполнение будет уходить всё равно один такт.
Кажется, нужен дополнительный триггер "команда прочитана и готова к выполнению".
Он будет сброшен на момент чтения первой команды. И сразу после выпонения перехода!
Видимо будут проблемы с командами CALL, RET, RETI, JMP...
