заказать платы:
5 MUX4:1 v3
5 переходник 273
10 RegLED
10 MUL

заказать платы:
RegLed3
CMP
INV-B
INV-BB
RAM?

хочется:
Flags
JMPS
RAM
ROM
Addr Counter
Osc

MUL, ALU - похожи на stripboard


Сделано прям сейчас в железе:

 0 1 2 3 4 5 6 7 8 9 A B C D E F
      4 + 2 + 2 + 8
|  COP  |DST|SRC|  MAYBE CONST  | N
---------------------------------
|  ADD  |DST|SRC|       -       | 0  // вообще-то здесь есть 8 свободных бит, которые можно спокойно потратить для модификации команды
| ADDC  |DST|SRC|       -       | 1  // и сделать из неё INC, DEC, ...
|  AND  |DST|SRC|       -       | 2
|   OR  |DST|SRC|       -       | 3
|  XOR  |DST|SRC|       -       | 4
|  MOV  |DST|SRC|       -       | 5
|  UNO  |DST|TYP|       -       | 6  // INV SWAP LSR LSRC
|  MUL  |DST|SRC|       -       | 7
|  LDI  |DST| - |     CONST     | 8  // SRC здесь не используются, но можно переключать константу между: 1, 2, CONST, 0xFF
|   LD  |DST|EXT|     CONST     | 9  // EXT может переключать входы сумматора RAM по принципу: ADDR = R3:R2*EXT[0] + CONST; EXT[1] переключает на пару R1:R0
|   IN  |DST|PRT|       -       | A  // PRT - номер порта, откуда будем вводить данные
|  OUT  |PRT|SRC|       -       | B  // PRT - номер порта, куда будем выводить данные
|   ST  |SRC|EXT|     CONST     | C  // SRC стоит на месте DST, т.к. для команды есть отдельный мультиплексор, подключенный к шине OUT
| CTRL  | FLAGS |       -       | D  // CLRF STOP [INC SP ; DEC SP]
|  CMP  |DST|SRC|       -       | E
| BRANC |  TYPE |  8 BIT ADDR   | F  // CALL, JMP, RET, JZ, JL, JNE, JG, -, JE, JC, JNZ, JNC
                                     // переход сейчас только относительный и только в пределах +-127 команд
                                     // но есть несколько свободных команд, можно сделать FARJMP, а лучше JMP по абсолютному адресу
план:
доделать подключение RAM, сделать переключение между парами регистров и зануление регистров в мультиплексорах
сделать плату портов
реализовать команды IN + OUT
поменять ROM на 16 бит, ибо задолбало
нарисовать/протравить плату ROM
врезать в АЛУ инвертор и шинник перед бинарными командами,
 (последний нужен для того, чтобы при подключении константы не случилось КЗ)
+добавить на АЛУ разъёмов, чтобы два раза не разбирать
+сделать новую плату==стрипбоард MUL, закрепить под АЛУ!
реализовать команду INC
поменять MUX4:1 на новые, с шинными формирователями
переделать счётчик адреса, использовать старые MUX4:1
(хотя лучше нарисовать новые, узкие)
реализовать команду FARCALL (пусть будет AFCALL - absolute far call)
стек для CALL!!
переделать мультиплексор, который делает из DST+SRC указатель,
 кажется, можно посто отрезАть младший бит, и пускать на мультиплексоры захардкоженные 0/1

Можно добиться минимальной кровью
(так как ADDI, ANDI до сих пор нет, лишние регистры не помешают):
                      4   +  3 + 1 + 3  +    5    = 16
                   0 1 2 3 4 5 6 7 8 9 A B C D E F
                  |  COP  | DST |*| SRC | MB CONST| N  // бит * может работать по разному, для разных команд
 cmd structure    ---------------------------------    // bits: d - DST, s - SRC, C - UseCF, I - InvSRC, F - ForceCF, Z - ZeroSRC, v - const
0000ddd0sss---ZI  |   AND | DST |0| SRC |  -  |Z|I| 0  //       p - PORT, P - REGISTER PAIR, o - OFFSET, typ - TYPE, a - ADDR
0000ddd1vvvvvvvv  |  ANDI | DST |1|  8 BIT CONST  | 0  // константа вместо регистра (нужен дополнительный шинный формирователь на шину SRC, но он конфликтует с битом I)
0001ddd0sss---ZI  |    OR | DST |0| SRC |  -  |Z|I| 1  // не понятно, нужны ли биты I+Z для команд AND/OR/XOR
0001ddd1vvvvvvvv  |   ORI | DST |1|  8 BIT CONST  | 1  // константа вместо регистра
0010ddd0sss---ZI  |   XOR | DST |0| SRC |  -  |Z|I| 2
0010ddd1vvvvvvvv  |  XORI | DST |1|  8 BIT CONST  | 2
0011ddd0sss---ZI  |   MOV | DST |0| SRC |  -  |Z|I| 3  // с MOV, кстати, тоже будет работать, поэтому можно сделать R1 := INV(R0), или типа того
0011ddd1vvvvvvvv  |  MOVI | DST |1|  8 BIT CONST  | 3
0100ddd0sss---ZI  |   MUL | DST |0| SRC |  -  |Z|I| 4  // а команда MUL в сочетании с ZeroSRC позволит занулить сразу два регистра
0100ddd1vvvvvvvv  |  MULI | DST |1|  8 BIT CONST  | 4  // константа

0101ddd-typ-----  |   UNO | DST |-| TYP |  -      | 7  // INV SWAP LSR LSRC (кстати, теперь здесь есть ещё 4 свободных слота!)

0110ddd0sss--FZI  |   ADD | DST |C| SRC | - |F|Z|I| 5  // есть 4 бита, для модификации команды UseCF(C), InvSRC(I), ForceCF(F), ZeroSRC(Z)
0111ddd1vvvvvvvv  |  ADDI | DST |C|  8 BIT CONST  | 6  // чтобы сделать из неё INC, INCC, DEC, DECC, SUB, SUBC
1000dddZPooooooo  |    LD | DST |Z|P| 7BIT OFFSET | 8  // Z может переключать входы сумматора RAM по принципу: ADDR = R7:R6*E + CONST, P переключает на пару R5:R4
1001sss-pppppppp  |    IN | DST |-|  7 BIT PORT |I| 9  // PORT - номер порта, откуда будем вводить данные, I - проинвертировать вводимое значение
1010sss-pppppppp  |   OUT | SRC |-|  8 BIT PORT   | A  // смотри ниже... (придётся использовать тот же мультиплексор, что и для памяти)
1011sssZPooooooo  |    ST | SRC |Z|P| 7BIT OFFSET | B  // SRC стоит на месте DST, т.к. для команды ST есть отдельный мультиплексор, подключенный к шине OUT
1100flg---------  |  CTRL |FLAGS|-|          -    | C  // CLRF STOP/DBG SETCF
1101dddCsss-----  |   CMP | DST |C| SRC |    -    | D  // окей, а здесь есть свободные биты для организации CMPC
1110dddCvvvvvvvv  |  CMPI | DST |C|  8 BIT CONST  | E
1111typeaaaaaaaa  | BRANC |  TYPE |  8 BIT ADDR   | F  // CALL, JMP, RET, JZ, JL, JNE, JG, RETI?, JE, JC, JNZ, JNC [AJMP, FJMP]
                   0 1 2 3 4 5 6 7 8 9 A B C D E F     // окей, есть 8 бит.... хорошо, но мало. нужен FARJMP, и опять таки ABSJUMP :((

план:
перенести биты SRC туда же, где биты CONST
заменить мультиплексоры на MUX8:1
протестировать на той системе команд, что есть ;)

перенести подключение константы с шины OUT на шину SRC
нарисовать/протравить новую плату декодера команд
снова всё соединить
переделать RAM, добавить на эту же плату ROM, развернуть разъём OFFSET
прикрутить UART
добавить банк памяти

кстати, при переезде на команду MUL1, в качестве счётчика адреса, можно сделать MUL1 + MUL1 + MUX + мелкая логика = 16 бит адрес + FARJMP
то есть, можно будет воткнуть несколько "сервисных" процедур в верхние адреса, с шагом по 256 байт, и с переходом по абсолютным адресам

можно попробовать сделать так:
    4   +  3  +1+  3  +   5   = 16
 0 1 2 3 4 5 6 7 8 9 A B C D E F
------------------------------------
|  ADD  | DST |0| SRC |-|Z|z|I|-| 00  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
| ADDC  | DST |0| SRC |-|Z|z|I|F| 01  // F - установить CF в 1, z/Z - занулить младший/старший нибл SRC, I - инвертировать SRC
|  AND  | DST |0| SRC |-|Z|z|I|-| 02  // примеры: INC => ADD Rx, x ; F=1 + Z=1 + z=1
|   OR  | DST |0| SRC |-|Z|z|I|-| 03  //          MOV R1, 60h ; ADD R1, R2 ; Z=1 => отковырять младший нибл и сделать из него символ
|  XOR  | DST |0| SRC |-|Z|z|I|-| 04  //          XOR R1, R1 ; z=1 => занулить только старший нибл
|  MOV  | DST |0| SRC |-|Z|z|I|-| 05  //          AND R1, R2 ; I=1 => проинвертировать R2 и сделать AND с R1
|  MUL  | DST |0| SRC |-|Z|z|I|-| 06  //          ADD R1, R2 ; I=1 => проинвертировать R2 и сделать ADD с R1 => SUB R1, R2!
|  UNO  | DST |0|TYP|-|-|Z|z|I|F| 07  // INV SWAP LSR LSRC ; флаг CF=1 даст для LSR единичку в старшем бите, остальные флаги меняют SRC, который здесь не используется
| *LPM* | DST |0|EXT|D|U|OFFSET4| 08  // ROM/RAM ADDR = PTR + OFFSET4;  OFFSET4 - максимальное смещение +-8 байт
|   LD  | DST |0|EXT|D|U|OFFSET4| 09  // EXT переключает PTR на пару R13:R12 (X) / R15:R14 (Y) / SP (4 пары регистров, одна пока не используется)
|   IN  | DST |0|PORT |-|-|-|I|-| 0A  // I/i инвертировать ли порт при IN                                              // PUSH Rx => ST [SP], Rx   ; DEC SP
|  OUT  |PORT |0| SRC |-|O|o|X|x| 0B  // XOR-ить ли порт (X, x) (мл.нибл) при OUT и какой нибл (O, o) вообще выводить  // POP  Rx => LD Rx, [SP-1] ; INC SP
|   ST  | SRC |0|EXT|D|U|OFFSET4| 0C  // U => UP - автоинкремент регистра после операции, D => DOWN - автодекремент регистра
| CTRL  |    FLAGS    |    -    | 0D  // CLRF, STOP, [INC SP, DEC SP]
| BRNCH |TYPE |0|   8 bit ADDR  | 0E  // CALL, JMP, RET, JZ, JL, JNE, JG, NOP - переход в +-127 команды, значение прибавляется к текущему счётчику команд
|  CMP  | DST |0| SRC |-|  -    | 0F  //   JE, JC, JNZ, JNC, --, --, STP, AFCALL - Absolute Far Call - 8 bit ADDR кладём в старшие биты и ничего не добавляем
                                      //   0    1    2    3   4   5    6   7


Вариант от 11.12.2023:
Убрал LDI и CTRL.
Добавил LPM и CMPC.

Легенда (действия с SRC перед подачей в АЛУ):
Z - занулить старший ниббл
z - занулить младший ниббл
I - проинвертировать старший ниббл
i - проинвертировать младший ниббл
C - переключить шину SRC на константу
    (в этом режиме отключается зануление и инверсия за ненадобностью)

F - установить флаг CF в 1 на время выполнения операции
O - вывести старший ниббл в порт
o - вывести младший ниббл в порт
X - поксорить порт со старшим нибблом
x - поксорить порт со младшим нибблом
P - дополнительные биты номера порта
X, Y - регистры-указатели  // LD R1, X
+X - автоинкремент после операции
-X - автодекремент после операции
X + 1 - прочитать/записать ячейку памяти по указателю X + 1
+X + 1 - то же самое, но указатель после операции проинкрементировать
TYP - тип унарной операции: -INV-, SWAP, LSR, LSRC, [SHUFFLE, MIRROR]
EXT - какую пару регистров использовать в качестве указателя (R7:R6, R5:R4, SP)
BTYPE - тип команды перехода (или команды управления)

    4   +  3  +1+  3  +   5   = 16
 0 1 2 3 4 5 6 7 8 9 A B C D E F
------------------------------------
|   ADD | DST |C| SRC |-|Z|z|I|i| 00  // ADDI R0, 1
|  ADDC | DST |C| SRC |F|Z|z|I|i| 01  // ADDC R1, 1 (+F=1)  // INC R0; INCC R1;
|   AND | DST |C| SRC |-|Z|z|I|i| 02  // ANDI R2, 0x0F
|    OR | DST |C| SRC |-|Z|z|I|i| 03  // ORI R3, 2
|   XOR | DST |C| SRC |-|Z|z|I|i| 04  // XORI R4, 4
|   MOV | DST |C| SRC |-|Z|z|I|i| 05  // MOVI R5, 5   // LDI R5, 5
|   MUL | DST |C| SRC |-|Z|z|I|i| 06  // MULI R6, 10  // R7:R6 := R6*10
|   UNO | DST |0|TYP|-|F|Z|z|I|i| 07  // теперь, когда инвертор есть на шине SRC можно выкинуть команду INV и заменить её... на SHUFFLE? MIRROR?
|   LPM | DST |0|EXT|D|U|OFFSET4| 08  // LPM R0, +X   // LPM R1, X+1  // LPM R1, -X-1
|    LD | DST |0|EXT|D|U|OFFSET4| 09  // LD R1, Y-
|    IN | DST |0|PORT |P|-|-|I|i| 0A  // IN R2, PIN1  // IN R2, ~PIN1 // инвертировать порт перед чтением
------------------------------------  всё что ниже - не модифицирует регистры
|   OUT |PORT |0| SRC |P|O|o|X|x| 0B  // OUT PORT0, R2  // XOUT PORT0, R2
|    ST | SRC |0|EXT|D|U|OFFSET4| 0C  // ST Y, R2
|   CMP | DST |C| SRC |-|   -   | 0D  // CMPI R3, 10
|  CMPC | DST |C| SRC |-|   -   | 0E  // CMPCI R4, 10
| BRNCH | BTYPE |   8 bit ADDR  | 0F  // CALL, JMP, RET,  JZ,   JL, JNE, JG, NOP  - переход в +-127 команды, значение прибавляется к текущему счётчику команд
                                      //   JE,  JC, JNZ, JNC, STOP,   -,  -, AFCALL - Absolute Far Call - 8 bit ADDR кладём в старшие биты и ничего не добавляем
                                      //    0    1    2    3     4     5     6    7

// Бит 7 кода операции указывает на то, что нужно переключить шину SRC на константу
// Его нужно использовать, если команда из первой половины списка, или если код команды 0D|0E

PORT0 - порт вывода 0 (бит 0 подключен к LCD.RS, бит 7 к LCD LED, биты 1+2 к линиям опроса кнопок)
PORT1 - порт вывода 1
PORT2 - LCD Data, запись происходит по фронту OUT2
PORT3 - порт вывода 3 (под эти 4 порта можно сделать отдельную плату)
PORT4 - DDR == функции пинов PORT3, ввод или вывод (почти как в AVR)
PORT5 - порт вывода 4
PORT6 - DDR == функции пинов PORT4, ввод или вывод (почти как в AVR)

Туду:
придумать некий универсальный интерфейс для шилдов, чтоб можно было подключать то LCD, то светодиодные матрицы...

Есть ещё команда OUT, и регистр флагов можно разместить в этом адресном пространстве.
PORT7 - порт для управления регистром флагов
           0     1    2    3    4     5   6   7
        | HCF | CF | ZF | LF | ~EQ | GF | - | BF |
  CLRF     0     0    0    0    0     0        0
 SETCF     0     1    0    0    0     0        0
(HCF - Half Carry Flag - перенос из 3 в 4 разряды сумматора... как раз у меня два 4 битных сумматора есть)
(BF - Bank Flag)

PORT8-15 - можно отдать под UART (хотя... я ж хотел UART воткнуть в адресное пространство RAM Оо)

PIN0 - порт ввода, подключен к кнопка (сканируется сразу весь ряд)

PIN8-15 - можно отдать под UART

Подходящий LCD:
http://www.lcdwiki.com/3.5inch_Arduino_Display-UNO
по идее, он тоже ляжет на PORT0+1, вместо 1602
https://aliexpress.ru/item/1005006221009489.html?sku_id=12000036339571446
https://aliexpress.ru/item/1005005326045644.html?sku_id=12000036725418502
или такой:
http://www.lcdwiki.com/3.95inch_Arduino_Display-UNO

пары регистров:
 R1:R0
 R3:R2
 R5:R4 | X   // можно использовать как арифметические, так и как указатель X (EXT==0)
 R7:R6 | Y   // можно использовать как арифметические, так и как указатель Y (EXT==1)
       | SP  // стек, это отдельный регистр, но подключается на место R7:R6 в командах PUSH/POP (EXT==2)
       | 0   // просто ноль, можно использовать для чтения глобальных переменных из начала RAM (EXT==3)

SP, в отличии от всех остальных регистров, не нужно читать и писать...
Его нужно только инкрементировать/декрементировать и слать в RAM.
С другой стороны, есть готовый мультиплексор и лень городить ещё один.


16 бит мультиплексор адреса ROM
MUX LOW_ADDR HI_ADDR
00     ADDR +1/+CONST (CMD | JL... | RET?) - только здесь работает сумматор
01   CONST      00h   AFCALL      | команда перехода содержит только 8 бит адреса
10     DST      SRC   LPM         | поэтому приходится запихивать его либо в старший байт, либо в младший
11    ADDR     ADDR   IRQ to ADDR | а адрес прерывания всегда одинаковый, можно установить его перемычками
ТуДу: объединить AFCALL и IRQ, ибо в идеале мне нужен мультиплексор 5:1 :(

Нужна ли теперь команда INV, если есть MOV + I? Oo
Нужен ли теперь инкремент, если есть ADDI Rx, 1?

Именование:
OUT - просто OUT
XOUT - OUT + XOR - и назвать это TOGGLE (TGL? TGGL? TOG? TOGL?)
OUTL - вывод младшего ниббла
OUTH - вывод старшего ниббла
TOGLL - переключение битов младшего ниббла
TOGLH - переключение битов старшего ниббла

ТуДу:
процессор пока в работе, а компилятор написать уже хочется...
 поэтому надо написать эмулятор, а в нём уже писать компилятор!
перерисовать MUX8 в виде 100x150
сделать платы стека на 16 бит (сейчас на 8) и перенести светодиоды на бок
нарисовать плату регистров, снова, 100x150
поправить регистры на 193, заказать трафареты
переделать регистры с 593 на 273, добавить пин сброса, сделать чтобы пины совпадали с 193
или просто сделать все регистры на 193? их проще в SOIC-е разводить
нарезать уже плату ROM из stripboard
проверить везде именование C0, C1, C2 и сделать как-нибудь одинаково

Сколько нужно битов для трёхадресного процессора?
16 + 3 = 19. Вот только тогда константа не влезет.

| ADDC  | DST |0| SRC |F|Z|z|I|i| 01  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
INC  == ADDI  Rx, 1  ; Z+z
INC  == ADDCI Rx, 0  ; F+Z+z
INCC == ADDCI Rx, 0  ; Z+z  // а здесь ок, учитываем перенос
DEC  == ADD   Rx, FF ; Z+z+I

MOVI R1, '2'
ANDI R1, 0x0F ; окей, '2' -> 2


альтернатива:
|  ADD  | DST |0| SRC |C|F|Z|I|i| 00  // всё ещё есть свободное место для INC, INCC, DEC, DECC, SUB, SUBC
                       C - UseCF, F - ForceCF, Z - zero src, I - Inv src high nibble, i - Inv low nibble
INC == ADD Rx, 0 ; C+F+Z

R1:R0
01 01 +
FF FF =
01 00 == DEC
DEC  R0  ; иначе случайно выставленный бит переноса отнимет лишнюю единицу
DECC R1  ; иначе не дойдёт займ от предыдущего байта

ТуДу: переделать (*ROFL*) существующую команду OUT так, чтобы строб вырабатывался не путём дёргания отдельного бита, а из сигнала C1
это позволит упростить подключение LCD

адреса:
относительные - хорошо подойдут для jl, je, lpm (перейди на 10 байт назад, возьми данные на 10 байт вперёд)
абсолютные - подойдут для call, и  lpm (функция вызывается из нескольких мест и каждый раз считать смещение не ок,
                                        да и строки можно положить в захардкоженные адреса)

так как старший бит команды свободен, можно легко добавить переключение на константу по этому биту:
|  ADDI | DST |1|     CONST     | 10  // сложение с константой
| ADDCI | DST |1|     CONST     | 11  // сложение с константой
|  ANDI | DST |1|     CONST     | 12  // AND с константой
|   ORI | DST |1|     CONST     | 13  // OR с константой
|  XORI | DST |1|     CONST     | 14  // XOR с константой
|  MOVI | DST |1|     CONST     | 15  // MOV с константой (нужен ли тогда LDI?)
|  MULI | DST |1|     CONST     | 16  // MUL с константой (в данном случае прикол в том, что результат всё равно ляжет в ДВА регистра)
                                      // MUL r0, r7 ; r1:r0 := r0*r7 ; нужна ли при этом константа? хз
                                      // MULI r0, 3 ; r1:r0 := r0*3  ; вообще константа пригодилась бы
| -LPMI-| DST |1|      ADDR     | 18  // НАФИГ, ПУСТЬ ЛУЧШЕ БУДЕТ АВТОИНКРЕМЕНТ АДРЕСА
|  CMPI | DST |1|     CONST     | 1E  // CMP с константой
 0 1 2 3 4 5 6 7 8 9 A B C D E F

туду:
+сделать так, чтобы умножитель записывал и старшую половину результата
*переделать регистры на 74HC193 с тем, чтобы у них случился автоинкремент/декремент*
спаять мультиплексоры MUX8:1
поменять мультиплексоры на MUX8:1
перекинуть проводки SRC на другие биты
скоммутировать битики зануления и инверсии
добавить мультиплексор для переключения SRC на константу
добавить мультиплексор 257, т.к. теперь три бита SRC, а не два
  или убавить мультиплексор 257, т.к. можно просто отключать младший бит, а старшие оставить как есть
убрать шинник подключения константы к OUT

+переделать INV-B и добавить на него шинник?
протравить новый инвертор INV-B с двумя входами
не забыть, что я хотел переставить местами команды BRANCH/CMP и UNO/MUL

подумать, не сделать ли стек в виде просто 74HC161/193 (или как там называется двоичный реверсивный счётчик)
типа так:
ADDR = PTR + OFFSET4;
EXT[2:1] переключает PTR на пару R1:R0 / R3:R2 / R5:R4 / R7:R6
EXT[0] - переключает "банк", с тем, чтобы SP жил сам по себе и не мешал другим регистрам
                      банк 0       0   /   Z   /   Y   /   X
                      банк 1       0   /   ?   /   BP  /   SP
В принципе, можно не городить отдельный большой MUX8:1, а прям рядом с RAM поставить MUX2:1,
один его вход подключить к шинам SRC/DST, как сейчас, а второй подвести к SP.
Можно даже сделать отдельную плату из 4 регистров SP и 4 мультиплексоров 2:1.

Какие операции могут случиться:
strcpy(a, b)
do {
 R0 := [X]
 X++
 [Y] := R0
 Y++
} while (R0)

print(str)
BP := SP
[BP+0] := str addr low
[BP+1] := str addr high
call print

чтение глобальной переменной:
X = addr  ; запись в два регистра R7:R6
R0 := [X]

сортировка:
SORT:
R0 := [X]
R1 := [X+1]
CMP R0, R1
JL SKIP
[X] := R1   ; SWAP
[X+1] := R0
SKIP:
INC  R6
INCC R7
JMP SORT

 Z  I  SRC
 ----------
 0  0  SRC
 0  1  !SRC
 1  0  0
 1  1  FF

CALL/RET:
MUX4:1
00 - IP := IP + 1/CONST  // STEP/JMP/CALL
01 - IP := [SP++]        // RET  (здесь другой SP)
10 - IP := CONST << 8    // AFCALL | IRQ ADDR == 0 (у мультиплексора есть вход EN, который обнуляет всё)
11 - IP := R3:R2         // LPM ADDR (в принципе, ничто не мешает взять X/Y с выхода мультиплексоров регистров и кинуть сюда)


CTRL имеет 6 свободных бит
0 - CLRF
1 - ? можно вкрутить инкремент/декремент пар регистров
или установку триггера, который всегда будет делать инкремент после операции чтения/записи

или даже вот так:
 0 1 2 3 4 5 6 7 8 9 A B C D E F
      6     + 2 + 2 = 10
|     ADD   |DST|SRC|     -     | 0
|    ADDC   |DST|SRC|     -     | 1
|     AND   |DST|SRC|     -     | 2
|      OR   |DST|SRC|     -     | 3
|     XOR   |DST|SRC|     -     | 4
|     MOV   |DST|SRC|     -     | 5
|     MUL   |DST|SRC|     -     | 6
|     UNO   |DST|TYP|     -     | 7
|     LDI   |DST|       CONST   | 8   // 6 + 2 + 8 = 16
|      LD   |DST|SRC|   CONST   | ?   // УПС! было смещение от 0 до 255, стало до 63 ;)
// недостающие биты можно размазать на несколько команд: LD (оба значения), LDO (только смещение), LDA (только адрес R3:R2)
|      LD   |DST|       CONST   | 9   // R3:R2 + CONST
|     LDA   |DST|         -     | A   // R3:R2
|     LDO   |DST|       CONST   | B   // CONST

|      IN   |DST|SRC|     -     | C
|     OUT   |DST|SRC|     -     | D
|      ST   |DST|SRC|   CONST   | E/F/10

|    CTRL   |  FLAGS|     -     | 11   // теперь не нужна, можно сделать CLRF
|     CMP   |DST|SRC|     -     | 12
|    CMPC   |DST|SRC|     -     | 13

и теперь можно чего-нибудь добавить:
|     SUB   |DST|SRC|     -     | 14
|     SBC   |DST|SRC|     -     | 15
|    ADDI   |DST|      CONST    | 16
|   ADDCI   |DST|      CONST    | 17
|    ANDI   |DST|      CONST    | 18
|     ORI   |DST|      CONST    | 19
|    XORI   |DST|      CONST    | 1A
|    MOVI   |DST|      CONST    | 1B
|    MULI   |DST|      CONST    | 1C
|    SUBI   |DST|      CONST    | 1D
|    SBCI   |DST|      CONST    | 1E
|    CMPI   |DST|      CONST    | 1F
|   CMPCI   |DST|      CONST    | 20

|     INC   |DST|         -     | 21
|    INCC   |DST|         -     | 22
|     DEC   |DST|         -     | 23
|    DECC   |DST|         -     | 24

|     LPM   |DST|      ADDR     | 25
|    LPMA   |DST|         -     | 26  // читаем из R3:R2, например

остались не заняты: 26, 27, 28, 29, 2A

|  BRANCH   | TYPE  |  OFFSET   | ?   // а вот с переходами стало как-то совсем грустно :(

но можно сделать так:
|    JMP    |       OFFSET      | 2B  // 6 + 10
|   CALL    |       OFFSET      | 2C  // 6 + 10
|    RET    |          -        | 2D  // 6 + 10
|     JL    |       OFFSET      | 2E  // 6 + 10
|     JE    |       OFFSET      | 2F  // 6 + 10
|     JG    |       OFFSET      | 30  // 6 + 10
|    JNE    |       OFFSET      | 3A  // 6 + 10
|     JC    |       OFFSET      | 3B  // 6 + 10
|    JNC    |       OFFSET      | 3C  // 6 + 10
|     JZ    |       OFFSET      | 3D  // 6 + 10
|    JNZ    |       OFFSET      | 3E  // 6 + 10
|    NOP    |       OFFSET      | 3F  // 6 + 10

туду: переупорядочить как-то команды, чтобы минимизировать логику

------------------------------------------------------------------
6 бит -> 64 команды -> 0..63 -> 00..3F
         4*16

собираем в кучу:

CMD     CONST
TYPE  REQUIRED - этот же бит входит в состав кода операции, но пишу я его отдельно, просто чтобы видеть значение бита
 ||      ||
 \/      \/
// команды на 0 (нужен дешифратор на 8)
// используют CONST как надо, переключают мультиплексор
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP Const // младший бит тоже является кодом операции,
|00   ADD 0|DST||SRC|     -     | 00  00 000 0     // но также указывает на необходимость использования константы
|00  ADDI 1|DST||      CONST    | 01  00 000 1
|00  ADDC 0|DST||SRC|     -     | 02  00 001 0
|00 ADDCI 1|DST||      CONST    | 03  00 001 1
|00   SUB 0|DST||SRC|     -     | 04  00 010 0
|00  SUBI 1|DST||      CONST    | 05  00 010 1
|00  SUBC 0|DST||SRC|     -     | 06  00 011 0
|00 SUBCI 1|DST||      CONST    | 07  00 011 1

|00   AND 0|DST||SRC|     -     | 08  00 100 0
|00  ANDI 1|DST||      CONST    | 09  00 100 1
|00    OR 0|DST||SRC|     -     | 0A  00 101 0
|00   ORI 1|DST||      CONST    | 0B  00 101 1
|00   XOR 0|DST||SRC|     -     | 0C  00 110 0
|00  XORI 1|DST||      CONST    | 0D  00 110 1
|00   MOV 0|DST||SRC|     -     | 0E  00 111 0
|00  MOVI 1|DST||      CONST    | 0F  00 111 1

// команды на 1 (нужен дешифратор на 16)
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP
|01   MUL 0|DST||SRC|     -     | 10  01 000 0  // чудес на свете не бывает, и результат всё равно ляжет в два регистра
                                                // поэтому нет смысла экономить на спичках, и умножать на константу
|01   LPM 1|DST||         -     | 11  01 000 1  // читаем память программ по адресу, лежащему в [R3:R2]
|01   UNO 0|DST||TYP|     -     | 12  01 001 0

// на данный момент эти константы подключены непосредственно к RAM
|01    LD 1|DST||     OFFSET    | 13  01 001 1  // LD Rx, [OFFSET] (load by offset) - чтение глобальных переменных (256 байт)
|01   LDA 0|DST||         -     | 14  01 010 0  // LD Rx, [R3:R2] (load by ptr) - чтение по указателю, а-ля *ptr
|01   LDO 1|DST||     OFFSET    | 15  01 010 1  // LD Rx, [R3:R2 + OFFSET] (load by ptr+offset) - чтение со смещением, а-ля *(ptr+1)

|01    IN 0|DST||SRC|     -     | 16  01 011 0

// для команды ST выделен отдельный мультиплексор, подключенный к шине OUT
// он получает биты S0:S1 из несколько непривычного места, а именно оттуда,
// откуда обычно достаются биты DST
// содержимое мультиплексора SRC, подаваемое на одноимённую шину, лучше бы занулить
|01    ST 1|S01||     OFFSET    | 17  01 011 1  // ST [CONST], Rx
|01   STA 0|S01||         -     | 18  01 100 0  // ST [R3:R2], Rx
|01   STO 1|S01||     OFFSET    | 19  01 100 1  // ST [R3:R2 + CONST], Rx

|01  CTRL 0|TYP||         -     | 1A  01 101 0  // всё та же старая команда CTRL, за которой прячется CLRF, STOP, ...
|01   OUT 1|DST||SRC|     -     | 1B  01 101 1  // просто вывод регистра в порт
                                                // гипотетически, можно выводить в порт именно константу
                                                // всё равно логика переключения шины SRC между регистром и константой "уже есть"
|01   CMP 0|DST||SRC|     -     | 1C  01 110 0
|01  CMPI 1|DST||      CONST    | 1D  01 110 1
|01  CMPC 0|DST||SRC|     -     | 1E  01 111 0
|01 CMPCI 1|DST||      CONST    | 1F  01 111 1

// команды на 2
// 6 + 10 бит (переход на +-512 байт)
 01 2 3 4 5 6 7  8 9 A B C D E F      CT COP
|10   JMP 0|        OFFSET      | 20  10 000 0
|10  CALL 1|        OFFSET      | 21  10 000 1
|10   RET 0|           -        | 22  10 001 0
|10    JL 1|        OFFSET      | 23  10 001 1
|10    JE 0|        OFFSET      | 24  10 010 0
|10    JG 1|        OFFSET      | 25  10 010 1
|10   JNE 0|        OFFSET      | 26  10 011 0
|10    JC 1|        OFFSET      | 27  10 011 1
|10   JNC 0|        OFFSET      | 28  10 100 0
|10    JZ 1|        OFFSET      | 29  10 100 1
|10   JNZ 0|        OFFSET      | 2A  10 101 0
|10   NOP 1|        OFFSET      | 2B  10 101 1
|10  FJMP 0|        OFFSET      | 2C  // FAR JUMP == JUMP TO OFFSET*16 (или на 64?)
|10 FCALL 1|        OFFSET      | 2D  10 110 0

// команды на 3 == LPM
// кода операции нет, команда выполяется при любых значениях, лишь бы первые два бита были 00 ;)
 01 2 3 4 5 6 7  8 9 A B C D E F        CT COP
    x x x x      x x x x x x x x                // <-- 12 бит
|11   ADDR |DST|       ADDR     | 3x  11 xxx x  // читаем по фиксированному адресу, всего 4096 адресов
                                                // память 16 битная Оо

структура команды:
тип  команда константа
2 бит  3 бит   1 бит
если (CMD TYPE == 0)
  выбираем команду ADD и логику для неё
если (CMD TYPE == 1)
  включаем дешифратор команд, который выбирает AND, MUL, ...
если команда == LPM
  переключаем генератор в режим трёх тактов
  подключаем к OUT мультиплексор с константой, прочитанной LPM
если (CMD TYPE == 2)
  подключаем много разной логики управления RAM, CLRF, OUT, CMP
если (CMD TYPE == 3)
  включаем логику переходов

карта памяти:
FFFF
  16550
FFF8
FFF7
  ROM
8000
7FFF
  RAM
0000

для 16550 доступ по указателю и смещению, наверное не нужен, достаточно кидать константу -1 == FFFF, -2 == FFFE...
на плату RAM добавляем ещё и ROM, а также отрезаем доступ по верхним 16-ти адресам
шины ADDR и CONST меняем местами (или всё же нет)

делаем отдельную плату, на которой располагаем 16550 и PCF8584 (I2C)
на этой плате наоборот делаем доступ по последним 16-ти адресам, и не делаем сумматора адресов

если ужаться до 32 команд, то на код операции уйдёт ровно 5 бит, и тогда можно перейти на 8 регистров,
а вся команда ляжет в 16 бит вместе с 8 бит константой

Любое увеличение команд/регистров свыше 16/4 приводит к тому, что я выхожу за пределы одного байта.
А это приводит к тому, что константу фиг прочитаешь.
Хотя...
Если просто взять 16 бит память, то константа остаётся внутри одного слова.
Хотя без константы часть битов будет пустой.

| 0 1 2 3 4 5 6 7 || 8 9 A B C D E F |
| -  COP  - D S T || S R C           |
| -  COP  - D S T ||    C O N S T    | - и каким мне боком теперь указывать, что здесь константа, а не SRC??
И в итоге всё равно мне нужно уместиться в 32 команды.

переделать проц, сделать так, чтобы:
шина OUT была 16 битной
это позволит более менее универсально сделать не только операцию MUL
но так же делать "сложные" команды а-я "сравнить два числа и переставить местами, если одно больше другого"
плюс "инкремент сразу пары регистров"
плюс "загрузка целого слова в пару регистров"

А лучше переделать его так, чтобы команда выполнялась за один такт!

можно попробовать сделать хитрые банки регистров
банк 1 - для арифметических вычислений
банк 2 - для регистров указателей
при этом банк два подключить к ДРУГОМУ мультиплексору, который будет отдавать адрес в RAM
Тогда получится, что указатели доступны всегда, но чтобы сделать инкремент - надо переключить банк.
Вроде это даже не очень больно.
Зато регистров - дофига.
Упс. Чтобы это сделать понадобиться отдельный мультиплексор для адресов и дополнительные выходы между регистрами и шинниками (там, где сейчас светодиоды стоят).

Альтернатива - нафиг банки, сделать хитрые регистры - счётчики на базе 74HC193.

Ещё можно выкинуть нафиг команду INV, если поставить на шину SRC инверторы, как и планировалось, и использовать команду MOV.
Но команду MOV тоже можно выкинуть, для этого можно использовать битик ZeroSRC (точнее, ZeroDST) и просто дёргать команду ... ADD!!

Чтобы не писать свой собственный код можно попробовать сделать эмулятор 8051 и брать прошивки от него.

Бесит:
слишком длинный код
 потому что нет ADDI и т.п.
  сделать уже ADDI, ANDI, ...
слишком неудобный CALL
 потому что нет абсолютных адресов
  сделать уже большой MUX16 и прикрутить туда всё, что нужно
нельзя проинвертировать бит порта, потому что есть только OUT PORT, REG
 то есть, сначала нужно положить что-то в регистр, потом вывести
  протравить уже плату Toggle, которую я уже нарисовал
ещё и регистр нужен, так как нельзя прочитать что-то из выходного порта
слишком мало регистров
 прикрутить уже MUX8:1 и спаять ещё регистров
отсутствие LPM вынуждает задавать строки посимвольно через LDI
 прикрутить к тому самому MUX16 какой-нибудь регистр, и брать из него указатель
