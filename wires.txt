
Список пинов/проводов/контантов на разных платах и их значение:

ROM
A0-A15 - вход, шина адреса, какие данные читать из ROM
CS - вход, включить микросхему ROM
C1 - вход, сигнал, по которому данные читаются из ROM и записываются в регистры
COP0-COP7 - шина, содержит команду, которую нужно выполнить
 (при выполнении команды LPM содержит старший байт данных)
CNST0-CNST7 - шина, содержит константу или адрес, которые используются в команде
BUS0-BUS7 - шина, содержит константу, которую можно подать шину данных,
 активируется сигналом LDI
LDI - вход, сигнал, переводит шинный формирователь в активное состояние и на шине данных появляется константа

RAM
A0-A15 - шина адреса
D0-D7 - шина данных, активируется сигналом логического 0 на входе OE
C0-C7 (CONST) - смещение, складывается со значением на шине адреса,
 сумма подаётся на шину адреса ОЗУ
CS - логический 0 активирует ОЗУ
OE - логический 0 подключает выходы озу к шине данных
WR - логический 0 производит запись данных с шины данных
 в ячейку памяти, адрес которой равен сумме шины адреса и константы

Regs
ALU Low Byte - вход данных, подключен к АЛУ, младший байт
ALU High Byte - вход данных, подключен к АЛУ, старший байт, нужен для команды MUL
 (эти же входы могут получать данные с RAM, ROM (LPM), портов)
Bank0 - вход, активирует регистры из банка 0
 (если подать логическую единицу включится банк 1)
Latch - вход, по этому сигналу данные запишутся в регистр
DST[0:2] - вход, в какой регистр писать данные по сигналу Latch
MUL - вход, активируется логическим 0, если активен - данные с ALU Low/High Byte
 будут записаны в два соседних регистра
Res - вход, если подать логическую 0, то все регистры обнулятся
R0-R7 - выходы регистров, подключаются к мультиплексорам

ALU
SRC - вход данных 1, подключен через мультиплексоры к регистрам данных
DST - вход данных 2, подключен через мультиплексоры к регистрам данных
OUT - выход данных, результаты вычисления
INVL, INVH - вход, инвертировать данные, полученные со входа SRC
 (можно отдельно младшую и старшую половны)
Latch - вход, по этому сигналу защёлкиваются данные внутри команд
 (сейчас не используется, данные сразу оказываются на выходе)
входы активации команды, записанные ниже, можно активировать только по одной штуке
 (иначе случиться короткое замыкание и всё сгорит):
ADDx - вход, активировать команду сложения
UseCF - нужно ли дополнительно прибавлять бит CF к сумме (ADDC)
AND/OR/XOR - логические команды
MOV - просто передаёт данные со входа SRC на выход OUT
команда CMP всегда сравнивает SRC и DST и всегда выдаёт результат на своих выходах
 (у этой команды OUT является входом, на нём проверяется наличие нуля)
CMP.Expand превращает команду CMP в CMPC, то есть, в сравнении участвует флаг CF

унарные команды, получают данные на входе DST, выдают результат на выходе OUT:
SWAP - активирует команду SWAP, переставить местами нибблы
LSRx - побитовый сдвиг вправо
UseCF - в процессе сдвига участвует флаг CF
RSRV - активирует команду RSRV, собственно, туда можно воткнуть что угодно ;)

MUL
A - вход данных 1, подключен через мультиплексоры к регистрам данных
B - вход данных 2, подключен через мультиплексоры к регистрам данных
OUTL - выход данных, результат вычисления, младший байт
OUTH - выход данных, результат вычисления, старший байт
MUL - вход, при подаче логического 0 выходы данных переходят из Z состояния в рабочее

MUX8:1
A-H - 8 входов данных, подключаются к регистрам
OUT - выход данных, подключается к ALU, MUL, ...
OE - вход, при подаче логического 0 выход данных переходит из Z состояния в рабочее
S0-S7 - входы, выбирают какой из входов данных будет подключен к выходу
EL, EH - входы, позволяют занулить один или оба ниббла выходных данных

Ports
Data - вход данных, подключен к LCD и паре регистров
BUS - выход данных, активируется логическим 0 на входе IN0.OE
IN0.C - вход, защёлкивает данные в выходном регистре по фронту импульса
IN0.OE - вход, подключает выходной регистр к шине BUS по логическому 0 на этом входе
OUT0 - защёлкивает данные в PORT0 по фронту импульса
OUT1 - защёлкивает данные в PORT1 по фронту импульса
OUT2 - подключен ко входу E LCD 1602, подробности в описании LCD 1602
регистр PORT0 имеет выходы, подключенные к входу RS LCD, кнопкам, подсветке LCD

Addr Counter
A, B, C, D - 16 бит входы мультиплексора,
 вход C подключен к выходу стека, вход D подключен к регистру адреса
O(OUT) - выход мультиплексора
+1/CONST - вход, при логической 1 делает шаг вперёд на CONST,
 при логической 0 делает шаг вперёд на 1
STEP - вход, шаг происходит по фронту импульса
S0-S1 - входы, выбирают один из входов A, B, C, D и подключают его к O
E - вход, при подаче логического 0 зануляет выходы O
входы стека подключаются навесным монтажём к логике

Flags гипотетический
GT, LT, EQ, ZF, CF1, CF2 - входы флагов
C2 - тактовый вход
CF Enable - вход, разрешает запись флага CF
ZF Enable - вход, разрешает запись флага ZF
CMP Enable - вход, разрешает запись флагов GT, LT, EQ
Res - вход, если подать логическую 0, то все флаги обнулятся
 (кроме EQ, он инверсный)
GT, LT, EQ, ZF, CF(три раза) - вЫходы флагов
(плюс инверсные CF и ZF)
НЕ ХВАТАЕТ!
HCF, BG, DBG

CMD_DEC гипотетический
входы:
COP0-COP3
C1
C2
SRC0-SRC2
выходы:
ADD, ADDC, ....
RAM_OE
RAM_WR
RAM_CS
CMP_EN
CF_EN
ZF_EN
LSR, SWAP, RSRV
UseCF
WILL_WR2REG
LATCH_REG
НЕ ХВАТАЕТ!
INVL, INVH
?

JUMPS гипотетический

Toggle
