
Список пинов/проводов/контантов на разных платах и их значение:

ROM
A0-A15 - вход, шина адреса, какие данные читать из ROM
CS - вход, включить микросхему ROM
C1 - вход, сигнал, по которому данные читаются из ROM и записываются в регистры
COP0-COP7 - шина, содержит команду, которую нужно выполнить
 (при выполнении команды LPM содержит старший байт данных)
CNST0-CNST7 - шина, содержит константу или адрес, которые используются в команде
BUS0-BUS7 - шина, содержит константу, которую можно подать шину данных,
 активируется сигналом LDI
LDI - вход, сигнал, переводит шинный формирователь в активное состояние и на шине данных появляется константа

Regs
ALU Low Byte - вход данных, подключен к АЛУ, младший байт
ALU High Byte - вход данных, подключен к АЛУ, старший байт, нужен для команды MUL
 (эти же входы могут получать данные с RAM, ROM (LPM), портов)
Bank0 - вход, активирует регистры из банка 0
 (если подать логическую единицу включится банк 1)
Latch - вход, по этому сигналу данные запишутся в регистр
DST[0:2] - вход, в какой регистр писать данные по сигналу Latch
MUL - вход, активируется логическим 0, если активен - данные с ALU Low/High Byte
 будут записаны в два соседних регистра
Res - вход, если подать логическую 0, то все регистры обнулятся
R0-R7 - выходы регистров, подключаются к мультиплексорам

ALU
SRC - вход данных 1, подключен через мультиплексоры к регистрам данных
DST - вход данных 2, подключен через мультиплексоры к регистрам данных
OUT - выход данных, результаты вычисления
INVL, INVH - вход, инвертировать данные, полученные со входа SRC
 (можно отдельно младшую и старшую половны)
Latch - вход, по этому сигналу защёлкиваются данные внутри команд
 (сейчас не используется, данные сразу оказываются на выходе)
входы активации команды, записанные ниже, можно активировать только по одной штуке
 (иначе случиться короткое замыкание и всё сгорит):
ADDx - вход, активировать команду сложения
UseCF - нужно ли дополнительно прибавлять бит CF к сумме (ADDC)
AND/OR/XOR - логические команды
MOV - просто передаёт данные со входа SRC на выход OUT
команда CMP всегда сравнивает SRC и DST и всегда выдаёт результат на своих выходах
 (у этой команды OUT является входом, на нём проверяется наличие нуля)
CMP.Expand превращает команду CMP в CMPC, то есть, в сравнении участвует флаг CF

унарные команды, получают данные на входе DST, выдают результат на выходе OUT:
SWAP - активирует команду SWAP, переставить местами нибблы
LSRx - побитовый сдвиг вправо
UseCF - в процессе сдвига участвует флаг CF
RSRV - активирует команду RSRV, собственно, туда можно воткнуть что угодно ;)

MUL
