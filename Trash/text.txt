
-0-
Прежде чем двигаться дальше, нужно сделать несколько выборов.
1. Мне очень не хотелось паять процессор из транзисторов. И не хотелось писать программу для ПЛИС. Поэтому я решил делать процессор из логических элементов.
2. Мне понравилась серия микросхем 74HC и я ориентировался на неё.
3. Эта серия микросхем содержит логические элементы, триггеры, регистры, счётчики, сумматоры.
4. Все эти элементы упакованы по 4 или по 8 штук. Именно поэтому я решил, что мой процессор будет восьмибитным (то есть, таким же как Arduino или Z80).
5. В принципе, можно просто взять вчетверо больше микросхем и получить 32 битый процессор, но, тогда он будет СЛИШКОМ большим ;)
Можно сказать, что основным элементом моего процессора будет микросхема 74HC573 (или 74HC574). Именно она позволяет хранить 8 бит данных и называется словом Регистр.
Данные защёлкиваются либо при подаче сигнала Latch (573), либо по фронту этого сигнала (574).
Слово Регистр может нести и другой смысл: это ячейка памяти в которой процессор хранит данные.
Регистр процессора "сделан" из микросхемы регистра.

-1-
Что делает процессор?
Обычно он обрабатывает данные!
Где он их хранит?
В регистрах!
Как он их обрабатывает?
С помощью АЛУ и в соответствии с программой!
Обычно у процессора есть несколько регистров и несколько команд. Например, Arduino Uno сделана из микроконтроллера Atmega328, внутри которого есть 32 регистра. И есть около сотни машинных команд для работы с этими регистрами.
Команда выглядит так (1).
(картинка вида C = A + B)
Однако обычно процессоры используют более простой вариант: A = A + B.
И в качестве операндов выступают регистры: R0 = R0 + R1.
Попробуем придумать машинный код для этой команды.
Перенумеруем регистры (2).
(картинка со списком регистров R0 - 00, R1 - 01, R2 - 10, R3 - 11)
Перенумеруем команды (3).
(картинка со списком команд ADD - 000, SUB - 001, MUL - 010, INC - 011, DEC - 100, CMP - 101, JMP - 110, JE - 111)
Сложим их в одно место (4).
(картинка с битами команды - COP|DST|SRC)
Ура! У нас есть битовое представление машинной команды.
Пример: процессор читает из памяти число 00001100. Это значит, что надо выполнить команду ADD над регистрами R3 и R0!

-2-
Где хранится программа?
Обычно в памяти.
Взаимодействие процессора и памяти происходит следующим образом (1):
(картинка с процом и памятью)
процессор выставляет на шину адреса число - адрес команды, которую он собирается выполнить;
память в ответ отдаёт число - машинный код команды, которую должен выполнить процессор;
адрес увеличивается на размер команды и процесс повторяется.
В чём подвох? Если мы возьмём 32 регистра, то нам понадобится 5 бит чтобы их перенумеровать.
Сотня команды потребует ещё 7 бит. Итого: 7 бит команды, 5 бит с номером одного регистра, 5 бит с номером другого = 17 бит.
Идём в магазин, видим там память на 8 и на 16 бит (2). Памяти на 17 бит нет :(
Что можно сделать? Уменьшить количество регистров. Или число команд. Или хранить команду в нескольких ячейках памяти.

-3-
Хорошо. Я купил память на 8 бит (AT28C16).
(картинка памяти)
(картинка распиновки)
Объём практически не важен, так как мегабайты кода я точно не напишу!
Надо решить, какие машинные коды будут у моего процессора.
Процессор может выполнять только простейшие команды. Например:
прочитать/записать значение из/в памяти в регистр;
выполнить арифметическую или логическую операцию с одним/двумя регистрами;
проверить значение в регистре;
перейти к выполнению другого участка кода, в зависимости от проверки.
У меня машинная команда будет занимать 8 бит. Я их поделю так:
4 бита код команды, 2 бита регистр DST, 2 бита регистр SRC. Биты кончились.
Я долго думал, какие команды выбрать. Выбрал такие (3).
(картинка с командами)
Для выбора регистра есть только два бита, а значит регистров будет 4.

-4-
Теперь можно нарисовать структуру процессора.
(картинка с регистрами, АЛУ, и чёрным ящиком вместо мультиплексора)
Как выбрать регистры, которые будут подключены к АЛУ? Для этого есть устройство - мультиплексор.
Я выбрал 74HC153, так как у меня только 4 регистра.
(фото)
(распиновка)
Он позволяет подключить 4 разных входа к одному выходу, в зависимости от состояния управляющих входов.
(ещё 4 картинки с пояснениями)

-5-
Модуль регистров я просто собрал из четырёх 74HC574 на breadboard.
Я выбрал именно 74HC574, а не 74HC573, так как данные должны защёлкнуться по фронту импульса.
Если выбрать 74HC573, то ничего не заработает: данные из регистра попадут в АЛУ, изменяться, попадут в регистр, потом опять на его выход, АЛУ опять что-то вычислит...
Если защёлкивать их по фронту, такой проблемы не будет!
(Фотка с платой регистров)

-6-
Фотка с платой мультиплексоров.
Фотка с подключением мультиплексоров к регистрам.

-7-
Фотка с платой АЛУ. (1)
АЛУ состоит из трёх шин: SRC, DST, OUT. Бинарные команды берут данные на SRC и DST, обрабатывают их, и выдают результат на шину OUT.
Унарные берут данные на DST и отдают на OUT. Каждая команда выполнена в виде отдельной платы.
Но как сделать так, чтобы на шине появились результаты работы только одной команды?
Можно было бы и здесь поставить мультиплексоры, но команд много, а мультиплексоры занимают место.
Поэтому я схитрил. Каждая команда имеет на выходе регистр 74HC573. Он используется не как регистр, а скорее, как выключатель.
Дело в том, что регистр 74HC573 имеет выходы с тремя состояниями. Если подать на вывод OE высокий уровень, то выходы 74HC573 перейдут в высокоимпедансное состояние. Проще говоря, будут отключены.
То есть, если подключить несколько 74HC573 к одной шине (OUT), и подать низкий уровень сигнала OE только на одну микросхему, то именно она и будет управлять шиной.
Сами по себе команды очень просты. Например, схема команды AND такая (2).
Здесь же я установил команду CMP, которая данные не обрабатывает, а просто устанавливает биты в регистре флагов.

-8-
Регистр флагов собран на breadboard (1).
(фото)
