<html>
<head>
<style type="text/css">
td {
width: 70;
}

td.mid {
width: 120;
}

td.tact {
width: 175;
}

td.big {
width: 250;
}

.over {
  text-decoration: overline;
}

tr.opt {
  background-color: silver;
}

</style>
</head>

<body>

<h2>Туду: подумать, куда досыпать светодиодов.</h2>

<h2>Что делаем</h2>
<p>Процессор, точнее МК, на базе 74HC серии, который имеет:</p>
<ul>
<li>8 бит шина данных;</li>
<li>16 бит шина адреса;</li>
<li>3 регистра для доступа к константе, портам ввода и вывода;</li>
<li>8 регистров общего назначения (и ещё 6 таких же теневых);</li>
<li>4 из них могут использоваться для чтения RAM (и 4 теневых);</li>
<li>12 бит размер команды;</li>
<li>54 команды (и 10 резервных), из них 14 арифметических;</li>
<li>хардварный стек на 8 уровней;</li>
<li>8 портов ввода и 8 портов вывода;</li>
<li>потенциально 256 портов вывода-вывода (внешняя шина 8 бит для адреса порта);</li>
<li>абсолютная/относительная адресация для адреса перехода;</li>
<li>8 бит регистра флага;</li>
<li>Гарвардская архитектура (ПЗУ команд, ОЗУ данных);</li>
<li>4 такта на команду;</li>
<li>нет видеокарты! вместо неё будет стандартный Arduino TFT LCD (примерно 320 x 240);</li>
<li>Предельная частота - ? Хорошо, если будет 1МГц!</li>
<li>Изменение выходного пина за 1 команду/4 такта!</li>
<li>Поддержка прерываний - один адрес. Нереентерабельные.</li>
</ul>

<h3>Минимальные требования:</h3>
<ul>
<li>максимально простой</li>
<li>чтобы не было мучительно больно программировать</li>
<li>критерий нормальности набора команд - возможно реализовать сортировку пузырьком/вставками без танцев с бубном</li>
<li>красивое!</li>
</ul>

<h4>Бесит!!</h4>
<ul>
<li>пока нет переходов по относительным адресам, а значит нельзя просто таскать программу по памяти вверх-вниз;</li>
<li>безумное количество мультиплексоров;</li>
<li>нет команды LPM для загрузки массива из ROM (хотя есть MOV r0, const - который является этаким разреженным массивом);</li>
</ul>

<h3>Регистры</h3>
<table border=1>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>r0-r7</td><td>Регистр общего назначения</td></tr>
<tr><td>r5:r4</td><td>Регистр X адреса ОЗУ</td></tr>
<tr><td>r7:r6</td><td>Регистр Y адреса ОЗУ</td></tr>
<tr><td>CONST</td><td>Регистр константы</td></tr>
</table>

<h3>Нумерация регистров</h3>
<table border=1>
<tr><td colspan=2>A(DST)</td><td colspan=2>B(SRC)</td><td class="big">Примечание</td></tr>
<tr><td>r0</td><td>000</td><td>r0</td><td>000</td><td></td></tr>
<tr><td>r1</td><td>001</td><td>r1</td><td>001</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r2</td><td>010</td><td bgcolor="#D5F5E3">r2</td><td>010</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r3</td><td>011</td><td bgcolor="#D5F5E3">r3</td><td>011</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r4</td><td>100</td><td bgcolor="#D5F5E3">r4</td><td>100</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r5</td><td>101</td><td bgcolor="#D5F5E3">r5</td><td>101</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r6</td><td>110</td><td>PORT0</td><td>110</td><td>Выходной порт 0! Позволяет не запоминать состояние порта и использовать данные порта сразу как операнд.</td></tr>
<tr><td bgcolor="#D5F5E3">r7</td><td>111</td><td>CONST</td><td>111</td><td>Константа, иногда лежит во втором слове команды</td></tr>
</table>

<p style="background-color:#D5F5E3">Можно переключить на другой банк!</p>

<p>Регистры DST доступны для записи, регистры SRC доступны для чтения. В старшие регистры r6-r7 можно писать, но, нельзя читать. Однако, они могут участвовать в арифметических операциях! И в CMP тоже! r6-r7 подключены к шине адреса ОЗУ.</p>

<h3>Порты</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>PORT0-7</td><td>Порт вывода 0-7, доступен через команду OUT, частично доступен через арифметические команды</td></tr>
<tr><td>PIN0-7</td><td>Порт ввода 0-7, доступен через команду IN</td></tr>
</table>

<h3>Список команд</h3>
<table border=1>
<tr><td colspan=5><h4>Бинарные команды (CTYPE=0)</h4></td></tr>
<tr><td colspan=5>Бинарная команда DST := DST OP SRC<br>
<b>Справа (SRC) могут быть не все регистры, ибо хвост занят портами и константой</b></td>
</tr>
<tr><td>Имя</td><td>COP</td><td class="mid">Операнды</td><td class="big">Описание</td><td>Длина</td></tr>
<tr><td>MUL</td><td>000</td><td>MUL r0, r1</td><td>Умножение. Результат выполнения ВСЕГДА ложится в соседнюю пару регистров, младший результат в младший регистр, старший в старший, причём используется одна из пар: r1:r0 или r3:r2, ... Пара выбирается по регистру DST.</td><td>1/2</td></tr>
<tr><td>ADDC</td><td>001</td><td>ADDC r0, r1</td><td>Сложение с переносом</td><td>1/2</td></tr>
<tr><td>ADD</td><td>010</td><td>ADD r0, r1</td><td>Сложение</td><td>1/2</td></tr>
<tr><td>AND</td><td>011</td><td>AND r0, r1</td><td>Побитовое И</td><td>1/2</td></tr>
<tr><td>OR</td><td>100</td><td>OR r0, r1</td><td>Побитовое ИЛИ</td><td>1/2</td></tr>
<tr><td>XOR</td><td>101</td><td>XOR r0, r1</td><td>Побитовое Исключающее ИЛИ</td><td>1/2</td></tr>
<tr><td>MOV</td><td>110</td><td>MOV r1, r2</td><td>Копирование из одного регистра в другой</td><td>1/2</td></tr>
<tr><td>LDIW</td><td>111</td><td>LDIW r1:r0, 16384</td><td>Загружает 16 бит значение в пару соседних регистров</td><td>2</td></tr>
<tr><td colspan=5><h4>Унарные команды (CTYPE=1)</h4>
DST := OP DST<br>
Регистр SRC не используется, команда подключается к шине DST.</td></tr>
<tr><td>CLR</td><td>000</td><td>CLR r1</td><td>Сброс всех битов</td><td>1</td></tr>
<tr><td>SET</td><td>000</td><td>SET r1</td><td>Установка всех битов</td><td>1</td></tr>
<tr><td>-</td><td>001</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>-</td><td>001</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>LSL</td><td>010</td><td>LSL r1</td><td>Побитовый сдвиг влево</td><td>1</td></tr>
<tr><td>LSLC</td><td>010</td><td>LSLC r1</td><td>Побитовый сдвиг влево с учётом переноса</td><td>1</td></tr>
<tr><td>LSR</td><td>011</td><td>LSR r1</td><td>Побитовый сдвиг вправо</td><td>1</td></tr>
<tr><td>LSRC</td><td>011</td><td>LSRC r1</td><td>Побитовый сдвиг вправо с учётом переноса</td><td>1</td></tr>
<tr><td>INV</td><td>100</td><td>INV r1</td><td>Побитовая инверсия</td><td>1</td></tr>
<tr><td>-</td><td>100</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>MIR</td><td>101</td><td>MIR r1</td><td>Зеркальный поворот, СЗР меняется с МЗР</td><td>1</td></tr>
<tr><td>-</td><td>101</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>SWAP</td><td>110</td><td>SWAP r5</td><td>Переставляет местами нибблы</td><td>1</td></tr>
<tr><td>-</td><td>110</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>INC</td><td>111</td><td>INC r6</td><td>Может инкрементить любой регистр. (Можно сделать из команды ADD, просто занулив один из операндов и зафорсить CF)</td><td>1</td></tr>
<tr><td>INCC</td><td>111</td><td>INCC r7</td><td>Тоже инкремент, но вторым аргументом берёт CF, а не единицу. В результате можно инкрементировать пару регистров (старший и младший).</td><td>1</td></tr>
<tr><td colspan=5><h4>Перехода (CTYPE=2)</h4>(абсолютные и относительные адреса)</td></tr>
<tr><td>[R]JZ</td><td>000</td><td>JZ ADDR</td><td>Переход если флаг ZF установлен</td><td>2</td></tr>
<tr><td>[R]JNZ</td><td>001</td><td>JNZ ADDR</td><td>Переход если флаг ZF сброшен</td><td>2</td></tr>
<tr><td>[R]JE</td><td>010</td><td>JE ADDR</td><td>Переход если флаг EF установлен</td><td>2</td></tr>
<tr><td>[R]JNE</td><td>011</td><td>JNE ADDR</td><td>Переход если флаг EF сброшен</td><td>2</td></tr>
<tr><td>[R]JG</td><td>100</td><td>JG ADDR</td><td>Переход если флаг GF установлен</td><td>2</td></tr>
<tr><td>[R]JL</td><td>101</td><td>JL ADDR</td><td>Переход если флаг LF установлен</td><td>2</td></tr>
<tr><td>[R]JC</td><td>110</td><td>JC ADDR</td><td>Переход если флаг CF установлен</td><td>2</td></tr>
<tr><td>[R]JNC</td><td>111</td><td>JNC ADDR</td><td>Переход, если флаг CF сброшен</td><td>2</td></tr>
<tr><td colspan=5><h4>Перехода (CTYPE=3)</h4>(абсолютные и относительные адреса)</td></tr>
<tr><td>[R]JS</td><td>000</td><td>JS ADDR</td><td>Переход, если флаг SF установлен</td><td>2</td></tr>
<tr><td>[R]JNS</td><td>001</td><td>JNS ADDR</td><td>Переход, если флаг SF сброшен</td><td>2</td></tr>
<tr><td>[R]JGE</td><td>010</td><td>JGE ADDR</td><td>Переход, если флаг GF или EF установлен</td><td>2</td></tr>
<tr><td>-</td><td>011</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>-</td><td>100</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>-</td><td>101</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>[R]JMP</td><td>110</td><td>JMP ADDR</td><td>Безусловный переход</td><td>2</td></tr>
<tr><td>[R]CALL</td><td>111</td><td>CALL ADDR</td><td>Вызов функции</td><td>2</td></tr>
<tr><td colspan=5><h4>Перехода (CTYPE=4)</h4></td></tr>
<tr><td>RET</td><td>000</td><td>RET</td><td>Возврат из функции</td><td>1</td></tr>
<tr><td>IRET</td><td>001</td><td>IRET</td><td>Возврат из прерывания (разрешает прерывания при выходе)</td><td>1</td></tr>
<tr><td>SIE</td><td>010</td><td>SIE</td><td>SKIP if Equal: пропускает следующую <b>двухсловную</b> команду, если стоит флаг EF. Сравнение не производит, т.к. оно может быть как 1, так и 2-словное.<br>
нужно доработать сумматор адреса, чтобы он выбирал +1/+2/+3 (размер SIE 1, значит можно просто вывод 1 тоже тянуть в 1).</td><td>1</td></tr>
<tr><td>SIZ</td><td>011</td><td>SIZ</td><td>SKIP if Zero (хорошо бы выбрать наиболее подходящий флаг, ибо zero может оказаться не лучшим выбором)</td><td>1</td></tr>
<tr><td>-</td><td>100</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>-</td><td>101</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>-</td><td>110</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>NOP</td><td>111</td><td>NOP</td><td>No operation</td><td>1</td></tr>
<tr><td colspan=5><h4>Управления (CTYPE=5)</h4></td></tr>
<tr><td>CLRF</td><td>000</td><td>CLRF</td><td>Очистка регистра флагов</td><td>1</td></tr>
<tr><td>DI</td><td>001</td><td>DI</td><td>Disable interrupt</td><td>1</td></tr>
<tr><td>EI</td><td>010</td><td>EI</td><td>Enable interrupt</td><td>1</td></tr>
<tr><td>BANK0</td><td>011</td><td>BANK0</td><td>Connect BANK0 of registers</td><td>1</td></tr>
<tr><td>BANK1</td><td>100</td><td>BANK1</td><td>Connect BANK1 of registers</td><td>1</td></tr>
<tr><td>STOP</td><td>101</td><td>STOP</td><td>Зависнуть!</td><td>1</td></tr>
<tr><td>RESET</td><td>110</td><td>RESET</td><td>Сброс процессора и переход к выполнению кода с нулевого адреса</td><td>1</td></tr>
<tr><td>-</td><td>111</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td colspan=5><h4>Передачи (CTYPE=6)</h4></td></tr>
<tr><td>LOAD[X|Y|SP]</td><td>000</td><td>LOADY r0</td><td>Загрузка из RAM[r7:r6] в регистр (r0-r7)</td><td>1</td></tr>
<tr><td>STORE[X|Y|SP]</td><td>001</td><td>STOREX r0</td><td>Запись в RAM[r5:r4] указанного регистра (r0-r7)</td><td>1</td></tr>
<tr><td>RLOAD[X|Y|SP]</td><td>010</td><td>RLOAD r0, [X+10]</td><td>Загрузка из RAM[r7:r6 + 10] в регистр (r0-r7)<br>74HC157/74HC151 имеет вход G, который позволяет занулять выходы, а значит можно очень легко суммировать с нулём и менять LOAD <-> RLOAD</td><td>2</td></tr>
<tr><td>RSTORE[X|Y|SP]</td><td>011</td><td>RSTORE [Y+10], r0</td><td>Запись в RAM[r5:r4 + 10] указанного регистра (r0-r7)</td><td>2</td></tr>
<tr><td>PUSH</td><td>100</td><td>PUSH r0</td><td>Записать регистр в стек</td><td>1</td></tr>
<tr><td>POP</td><td>101</td><td>POP r0</td><td>Прочитать регистр из стека</td><td>1</td></tr>
<tr><td>PUSHF</td><td>110</td><td>PUSHF</td><td>Записать регистр флагов в стек</td><td>1</td></tr>
<tr><td>POPF</td><td>111</td><td>POPF</td><td>Прочитать регистр флагов из стека</td><td>1</td></tr>
<tr><td colspan=5><h4>Ввода-вывода (CTYPE=7)</h4></td></tr>
<tr><td>IN</td><td>000</td><td>IN r0, PINx</td><td>Чтение из порта PINx в r0</td><td>1</td></tr>
<tr><td>OUT</td><td>001</td><td>OUT PORTx, r0</td><td>Вывод регистра r0 в заданный порт (PORTx)</td><td>1/2</td></tr>
<tr><td>XOUT</td><td>010</td><td>XOUT PORTx, r1</td><td>Вывод регистра r1 XOR r0 в заданный порт (слева может быть любой SRC, включая PORT0, однако XOR всегда происходит с r0)</td><td>1/2</td></tr>
<tr><td>INI</td><td>011</td><td>IN r0, [r1]</td><td>Чтение из порта с номером, который лежит в r1, и сохранение в регистр r0. Адреса не пересекаются с командой IN, и читать этой командой PIN0-7 невозможно.</td><td>1/2</td></tr>
<tr><td>OUTI</td><td>100</td><td>OUT [r1], r0</td><td>Вывод регистра r0 в порт, номер которого лежит в r1. Адреса не пересекаются с командой OUT, и писать этой командой PORT0-7 невозможно.</td><td>1/2</td></tr>
<tr><td>-</td><td>101</td><td>-</td><td>reserved</td><td>1/2</td></tr>
<tr><td colspan=5><h4>Last but not least (CTYPE=7)</h4>(вынесены сюда, т.к. не должны менять регистры, хотя и похожи на арифметические)</td></tr>
<tr><td>CMP</td><td>110</td><td>CMP r0, r1</td><td>Сравнение (устанавливает флаги, не портит регистры)</td><td>1/2</td></tr>
<tr><td>CMPC</td><td>111</td><td>CMPC r0, r1</td><td>Сравнение с учётом "переноса": проверяет флаги E/G/L от предыдущей операции</td><td>1/2</td></tr>
</table>

<p>Что можно сделать из команды сложения:</p>
<ul>
<li>ADD -> A + B + 0</li>
<li>ADDC -> A + B + CF</li>
<li>INC -> A + 0 + CF|1</li>
<li>INCC -> A + 0 + CF</li>
<li>DEC -> A + 0xFF</li>
<li>DECC -> A + 0xFF + CF</li>
</ul>

<p>Длина команды может быть 1 или 2. 2 для случая, когда команда содержит константу.<br>
Константы могут располагаться только по нечётным адресам.<br>
Константы могут быть в любой арифметической команде, а также в командах перехода.<br>
Команда CMP не меняет регистры (только флаги).</p>

<h3>Шины</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>A</td><td>Шина A - это выход мультиплексора по регистрам DST.</td></tr>
<tr><td>B</td><td>Шина B - это выход мультиплексора по регистрам SRC, вход для унарных команд</td></tr>
<tr><td>OUT</td><td>Шина OUT - это, фактически, выход АЛУ, то есть выход унарных и бинарных команд, <b>вход/выход для RAM</b>.
Можно было бы подключить вход RAM к DST, но тогда невозможно реализовать PUSHF.
<br>Попробовать совместить IN + STORE, всё равно к шине OUT подключается всё подряд.</td></tr>
</table>

<h3>Структура</h3>
<img src="CPU.png" width="730" />

<h3>Структура памяти программ</h3>
<p>Так как ROM на 12 бит ширины не существует, нужна альтернатива. Ближайшее кратное к 12 - это 24. И оно хорошо ложится на 3 байта.
Поэтому проще всего поставить 3 ROM параллельно, а 24 бита разрезать на две части мультиплексором. Получится ROM на 12 бит.
Это удобно и потому, что можно очень легко сделать команды как в одно машинное слово, так и в два.
Однако, ставить два мультиплексора жалко, поэтому двухсловные команды должны начинаться всегда с чётных адресов.
А константа всегда лежит вторым словом по нечётному адресу и автоматически читается, т.к. память всегда отдаёт <b>две</b> команды за раз.</p>

<img src="ROM.png" />

<h4>Побитовое размещение команд</h4>
<table border=1>
<tr><td colspan=8>ROM 2</td><td colspan=8>ROM 1</td><td colspan=8>ROM 0</td></tr>
<tr>
<td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
<td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
<td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
</tr>
<tr><td colspan=12>Word 1</td><td colspan=12>Word 0</td></tr>
<tr>
<td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
<td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
</tr>
<tr><td colspan=12>CMD | CONST</td><td colspan=12>CMD</td></tr>
</table>

<h4>Пример размещения команд</h4>
<p>Адреса растут справа налево, сверху вниз</p>
<table border=1>
<tr><td class="mid">Нечётные адреса</td><td class="mid">Чётные адреса</td><td class="big">Пояснения</td></tr>
<tr><td>CLR r0</td><td>BANK0</td><td>две команды в одной "строке" ROM</td></tr>
<tr><td>CONST (10)</td><td>ADD R0, 10</td><td>одна двухсловная команда</td></tr>
<tr><td>NOP</td><td>OUT PORT0, R0</td><td>опять две команды</td></tr>
</table>

<p>С точки зрения процессора команды будут размещаться так:</p>
<table border=1>
<tr><td class="mid">Адрес</td><td class="mid">Команда</td></tr>
<tr><td>0</td><td>BANK0</td></tr>
<tr><td>1</td><td>CLR r0</td></tr>
<tr><td>2</td><td>ADD R0,</td></tr>
<tr><td>3</td><td>CONST (10)</td></tr>
<tr><td>4</td><td>OUT PORT0, R0</td></tr>
<tr><td>5</td><td>NOP</td></tr>
</table>
<p>Сухой остаток: команды выбираются из ROM всегда по две за раз, младший бит адреса лишь перекидывает входы мультиплексора между ними.</p>
<p>В качестве ROM используется W27C512-45Z на 64КБ, значит сумарно 192КБ или 128 Килослова (128К однословных команд).</p>
<p>Так как счётчик адреса составляет 16 бит, старший (17-ый) бит не используется.
Можно повесить рубильник, чтобы подключать "альтернативную" прошивку.
Альтернатива - добавить в команду переходов дополнительный бит (он там как раз есть) и добавить ещё одну микросхему сумматора (плюс 4 бита к счётчику адреса).
Минус в том, что хвардварный стек сделан на 74HC573, и ширина у него строго 16 бит.</p>

<h3>Регистр флагов</h3>
<table border=1>
<tr><td>Бит</td><td class="mid">Имя</td><td class="big">Назначение</td></tr>
<tr><td>0</td><td>CF (carry flag)</td><td>устанавливается после выполнения сложения, если случился перенос;</td></tr>
<tr><td>1</td><td>SF (shift flag)</td><td>устанавливается после выполнения сдвига, если логическая 1 вышла за пределы регистра;</td></tr>
<tr><td>2</td><td>IE (interrupt enable)</td><td>устанавливается/сбрасывается командами EI/DI;
<br>собственно, если прерывание обрабатывается, то повторный вызов и так будет запрещён триггерами обработки прерывания;
<br>то есть, логика такая: если прерывание разрешено и если мы ещё не обрабатываем прерывание, то входим и обрабатываем.
<br>Флаг не восстанавливается командой popf, он как бы read only (только через EI/DI).</td></tr>
<tr><td>3</td><td>BF (bank flag)</td><td>устанавливается командной BANK1, сбрасывается командой BANK0;</td></tr>
<tr><td>4</td><td>ZF (zero flag)</td><td>устанавливается после выполнения любой арифметической операции, если результат операции ноль;</td></tr>
<tr><td>5</td><td>LF</td><td>Less that - устанавливается после выполнения операции CMP;</td></tr>
<tr><td>6</td><td class="over">EF</td><td>Equal (инвертированный) - устанавливается после выполнения операции CMP;</td></tr>
<tr><td>7</td><td>GF</td><td>Greater that - устанавливается после выполнения операции CMP;</td></tr>
</table>

<h3>Значение селектора</h3>
<table border=1 width=250>
<tr><td>SEL</td><td class="big">Адрес следующей инструкции берётся из:</td></tr>
<tr><td>00</td><td>сумматора (+1|+2)</td></tr>
<tr><td>01</td><td>константы адреса</td></tr>
<tr><td>10</td><td>стека</td></tr>
<tr><td>11</td><td>внешнего источника (IRQ)</td></tr>
</table>

<p>Селектор анализируется только если CTYPE == 1, то есть имеет смысл только для команд перехода. Ибо зачем нужен селектор, если после команды сложения обычно нужно просто выполнить следующую команду?</p>

<p>Вообще-то селектор не нужно хранить в команде, ибо сама команда и определяет селектор. Для арифметической команды SEL=0, для команды RET SEL=3, для прерывания, которое вообще не команда, SEL=2. Все команды перехода имеют SEL=1, то есть абсолютную адресацию. Если конечно переход случится!</p>

<h3>Структура бинарной арифметической команды</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE == 0</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC)</td></tr>
<tr class="opt"><td colspan=4>0000</td><td colspan=8>CONST[7:0] - значение, только для B(SRC) = 7</td></tr>
</table>

<h3>Структура унарной арифметической команды</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE == 0</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=2>-</td><td>Expand</td></tr>
</table>
<p>Свободные биты можно как-то использовать для расширения команды. Например, вынести туда флаг "использовать CF".</p>

<h3>LDIW</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=2>A(DST)</td><td colspan=4>CONST[15:12]</td></tr>
<tr><td colspan=3>0</td><td colspan=3>LDIW</td><td colspan=2>r1:r0, r3:r2, r5:r4, r7:r6</td><td colspan=4>const higher bits</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Младший бит A(DST) придётся принудительно взводить в 0, т.к. места под него в команде не хватило.</p>

<h3>Переходы</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td>-</td><td>REL</td><td colspan=4>CONST[15:12]</td></tr>
<tr><td colspan=3>2, 3, 4</td><td colspan=3>JMP, Jx, CALL</td><td>0</td><td>0/1</td><td colspan=4>const higher bits</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Биты 0-3 можно использовать как недостающие. Вместе с 12 бит константой они дадут полный 16 битный адрес.</p>
<p>Бит 4 - REL можно использовать, чтобы переключать команду перехода в относительный режим. Сбрасываем SEL в 0, а на сумматор адреса подаём константу, вместо +1/+2.</p>
<br>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>011|100</td><td colspan=3>SIE</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>
<br>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>011|100</td><td colspan=3>RET, IRET</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>

<h3>Управления</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>101</td><td colspan=3>CLRF, NOP, EI, DI</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>
<br>

<h3>LOAD</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td></td><td colspan=2>X/Y/SP/?</td></tr>
<tr><td colspan=3>110</td><td colspan=3>LOAD</td><td colspan=3>Rx</td><td></td><td colspan=2>00/01/10</td></tr>
</table>

<h3>RLOAD</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td></td><td colspan=2>X/Y/SP/?</td></tr>
<tr><td colspan=3>110</td><td colspan=3>RLOAD</td><td colspan=3>Rx</td><td></td><td colspan=2>00/01/10</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Хорошо подходит для сортировки пузырьком (взять текущий элемент и следующий за ним) и для доставания параметров из стека (SP+1 - первый параметр в стеке).<br>
Имеет 12 битный адрес, поэтому дальше чем 4096 Байт не дотягивается.</p>

<h3>STORE</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td></td><td colspan=2>X/Y/SP/?</td></tr>
<tr><td colspan=3>110</td><td colspan=3>STORE</td><td colspan=3>Rx</td><td></td><td colspan=2>00/01/10</td></tr>
</table>

<h3>RSTORE</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td></td><td colspan=2>X/Y/SP/?</td></tr>
<tr><td colspan=3>110</td><td colspan=3>RSTORE</td><td colspan=3>Rx</td><td></td><td colspan=2>00/01/10</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>

<p>Вход RAM подключен к шине OUT, а через неё к мультиплексору DST, поэтому здесь именно DST, а не SRC.</p>

<h3>IN</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>ADDR</td></tr>
<tr><td colspan=3>111</td><td colspan=3>IN</td><td colspan=3>r0-r7</td><td colspan=3>3 бита</td></tr>
</table>
<p>Адрес порта (0-7), из которого надо произвести чтение</p>

<h3>INI</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC)</td></tr>
<tr><td colspan=3>111</td><td colspan=3>IN</td><td colspan=3>r0-r7</td><td colspan=3>[r0-r5, PORT0, CONST]</td></tr>
<tr class="opt"><td colspan=4>0000</td><td colspan=8>CONST[7:0] - значение, только для B(SRC) = 7</td></tr>
</table>
<p>Адрес порта (0-255), берётся из регистра SRC, и из него производится чтение</p>

<h3>[X]OUT</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>ADDR</td><td colspan=3>B(SRC)</td></tr>
<tr><td colspan=3>111</td><td colspan=3>OUT</td><td colspan=3>3 бита</td><td colspan=3>r0-r5, PORT0, CONST</td></tr>
<tr class="opt"><td colspan=4>0000</td><td colspan=8>CONST[7:0] - значение, только для B(SRC) = 7</td></tr>
</table>
<p>Адрес порта (0-7), в который надо произвести запись (PORT0-7)</p>

<h3>[X]OUTI</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC)</td></tr>
<tr><td colspan=3>111</td><td colspan=3>OUT</td><td colspan=3>[r0-r7]</td><td colspan=3>r0-r5, PORT0, CONST</td></tr>
<tr class="opt"><td colspan=4>0000</td><td colspan=8>CONST[7:0] - значение, только для B(SRC) = 7</td></tr>
</table>
<p>Адрес порта (0-255), в который надо произвести запись, берётся из регистра DST.</p>

<h3>Выполнение команды JMP/Jx</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL]<br>0|1 в зависимости от результатов проверки флагов</td><td></td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды SIE (JE через одну следующую команду)</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|3, 3 если EF, 1 если not EF</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td></td><td></td><td></td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды CALL</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2<br>следующая за CALL команда</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0|1</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td></td><td>Push Addr<br>(сумматора, не мультиплексора)</td><td>HWSP++ (такой необычный стек)</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды RET</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1<br>будет потерян, ибо после RET ничего не выполняется</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>HWSP--</td><td>Pop Addr<br>(просто читаем вершину стека)</td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 3?</td><td>в этот момент адрес доедет из стека до мультиплексора</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение арифметической команды</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td>(выход команды подключается к шине OUT)</td><td>вычисляет</td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды IN</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>IN</td><td>(выход регистра подключается к шине OUT)<br>Latch PINx</td><td></td><td>Latch r0-r7</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды [X]OUT</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td>(выход команды подключается к шине OUT)</td><td>вычисляет<br>(команду XOR/MOV)</td><td>Latch IR</td><td>Latch PORTx</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды LOAD</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td></td><td>CS = 1</td><td>RD = 1<br>RAM соединён с шиной OUT<br>Latch r0-r7</td><td>CS = 0, RD = 0</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды STORE</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td>Вход RAM подключен к OUT</td><td>CS = 1, WR = 1</td><td>WR = 0, происходит запись в RAM</td><td>CS = 0</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды PUSH</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td>Вход RAM подключен к OUT, шина DST соединена с OUT</td><td>CS = 1, WR = 1</td><td>WR = 0, происходит запись в RAM</td><td>CS = 0, SP++</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды PUSHF</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td>Вход RAM подключен к OUT, регистр Flags соединен с OUT</td><td>CS = 1, WR = 1</td><td>WR = 0, происходит запись в RAM</td><td>CS = 0, SP++</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды POP[F]</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td>SP--</td><td>CS = 1</td><td>RD = 1<br>RAM соединён с шиной OUT<br>Latch r0-r7|Flags</td><td>CS = 0, RD = 0</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение IRQ (формально это не команда, но процесс ложится на наши 4 такта)</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>Логика прерываний</td><td>if (CTYPE==1|3??) T1 := 1</td><td>if (T1) T2 := 1<br>if (T2) Push Next Addr</td><td>-</td><td>if (T2) Latch IRQ Addr</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td>пока выполняется арифметическая команда</td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>Push Addr<br>(сумматора, не мультиплексора). Стек должен быть на 573, чтобы изменяющийся сумматор таки попал в него!</td><td>HWSP++ (такой необычный стек)</td><td></td></tr>
<tr><td>АЛУ</td><td></td><td></td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td>MUX <= COP[SEL] = 2<br>передумали ;)</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Порядок сборки модулей</h3>
<table border=1>
<tr><td>Модуль</td><td class="big">Что нужно для сборки</td><td>Корпусов</td></tr>
<tr><td>AND</td><td>74HC08*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>ADD/ADDC</td><td>74HC283*2, 74HC08, 74HC573 увы в DIP</td><td>4</td></tr>
<tr><td>MOV</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>ADD Flag</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CMP Flags</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CMP/CMPC</td><td>74HC85*2, 74HC08, лучше в SO</td><td>3</td></tr>
<tr><td>Regs, Bank0+1</td><td>74HC573*14, 74HC238, LEDs</td><td>9</td></tr>
<tr><td>ALU</td><td>74HC245*2, 74HC138*2, stripboard</td><td>4</td></tr>
<tr><td>CLR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSL</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>INV</td><td>74HC00*2, 74HC573, SO</td><td>3</td></tr>
<tr><td>OR</td><td>74HC32*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>XOR</td><td>74HC86*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>SET</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>OUT</td><td>74HC573*4, 74HC238</td><td>5</td></tr>
<tr><td>ADDR counter</td><td>74HC283*4, 74HC273*2, 74HC04</td><td>7</td></tr>
<tr><td>ADDR LED</td><td>GAL16*4, 7 seg LED*4</td><td>4</td></tr>
<tr><td>ROM</td><td>W27C512*3, 74HC573*3, 74HC157*3</td><td>9</td></tr>
<tr><td>ADDR MUX</td><td>74HC153*8</td><td>8</td></tr>
<tr><td>OSC</td><td>74HC04, 74HC161, 74HC139, 74HC00</td><td>4</td></tr>
<tr><td>RAM</td><td>UT62256*2, 74HC573*2, 74HC00</td><td>5</td></tr>
<tr><td>STACK</td><td>74HC573*16, SO, 74HC193, 74HC238</td><td>18</td></tr>
<tr><td>IN</td><td>74HC573, ?</td><td>1</td></tr>
<tr><td>Jump Logic</td><td>74HC238, 74HC08*2, 74HC4078</td><td>4</td></tr>
<tr><td>Interrupt Logic</td><td>74HC00*3, 74HC21 (или 74HC20)</td><td>4</td></tr>
<tr><td>CMD decoder</td><td>мелкая логика, которая связывает все предыдущие модули: 74HC21, 74HC139, ...</td><td>3+</td></tr>
<tr><td>MUL</td><td>74HC283*16, 74HC08*16, 74HC573*2</td><td>34!</td></tr>
<tr><td>MIR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>SWAB</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>Timer ;)</td><td>74HC193*4, 74HC573*2, 74HC00, ... считает в минус, загружается сам</td><td>7</td></tr>
<tr><td colspan=3>Итого - 170 корпусов</td></tr>
</table>

<h3>Ассемблер врукопашную</h3>
<table border=1>
<tr><td>COP/CTYPE</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>DST</td><td>SRC</td></tr>
<tr><td>0</td><td>MUL</td><td>CLR/SET</td><td>JZ</td><td>JS</td><td>RET</td><td>CLRF</td><td>LOAD</td><td>IN</td><td>r0</td><td>r0</td></tr>
<tr><td>1</td><td>ADDC</td><td>-</td><td>JNZ</td><td>JNS</td><td>IRET</td><td>DI</td><td>STORE</td><td>OUT</td><td>r1</td><td>r1</td></tr>
<tr><td>2</td><td>ADD</td><td>LSL/C</td><td>JE</td><td>JGE</td><td>SIE</td><td>EI</td><td>RLOAD</td><td>XOUT</td><td>r2</td><td>r2</td></tr>
<tr><td>3</td><td>AND</td><td>LSR/C</td><td>JNE</td><td>-</td><td>SIZ</td><td>BANK0</td><td>RSTORE</td><td>INI</td><td>r3</td><td>r3</td></tr>
<tr><td>4</td><td>OR</td><td>INV</td><td>JG</td><td>-</td><td>-</td><td>BANK1</td><td>PUSH</td><td>OUTI</td><td>r4</td><td>r4</td></tr>
<tr><td>5</td><td>XOR</td><td>MIR</td><td>JL</td><td>-</td><td>-</td><td>STOP</td><td>POP</td><td>-</td><td>r5</td><td>r5</td></tr>
<tr><td>6</td><td>MOV</td><td>SWAP</td><td>JC</td><td>JMP</td><td>-</td><td>RESET</td><td>PUSHF</td><td>CMP</td><td>r6</td><td>PORT0</td></tr>
<tr><td>7</td><td>LDIW</td><td>INC/C</td><td>JNC</td><td>CALL</td><td>NOP</td><td>-</td><td>POPF</td><td>CMPC</td><td>r7</td><td>CONST</td></tr>
</table>

<p>Переведём в машинный код команду ADD r0, 10:</p>
<ul>
<li>CTYPE - 0 (столбец 0)</li>
<li>COP - 2 (строка 2)</li>
<li>DST - 0 (строка 0)</li>
<li>SRC - 7 (строка 7)</li>
</ul>
<p>Слово 1: 0207<p>
<p>Слово 2: 0012<p>
<p>(оба числа восьмеричные)<p>

<p>Переведём в машинный код команду BANK0:</p>
<ul>
<li>CTYPE - 5 (столбец 5)</li>
<li>COP - 3 (строка 3)</li>
<li>DST - 0 (не используется)</li>
<li>SRC - 0 (не используется)</li>
</ul>
<p>Слово 1: 5300<p>

<h3>Примеры команд</h3>
<pre>
MOV r0, r1        ; r0 := r1
ADD r0, r1        ; r0 += r1
AND r3, CONST     ; r3 &= CONST
MOV r7, r1        ; r7 := r1
OR  r7, CONST     ; r7 |= CONST

OUT PORT1, r1     ; PORT1 := r1
OUT PORT1, CONST  ; PORT1 := CONST
OUT PORT2, r2     ; PORT2 := r2
OUT PORT3, PORT0  ; PORT3 := PORT0
XOUT PORT3, r2    ; PORT3 := r0 XOR r2
XOUT PORT3, PORT0 ; PORT3 := r0 XOR PORT0 - взять PORT0, проинвертировать часть битов, вывести в PORT3
XOUT PORT0, PORT0 ; PORT0 := r0 XOR PORT0 - фактически, это инвертирование битов порта, по маске в r0
XOUT PORT0, r2    ; PORT0 := r0 XOR r2

MOV r3, CONST     ; r3:= CONST

MOV r3, r7        ; ошибка! r7 нельзя просто прочитать

ADD r6, 1         ; инкремент пары регистров
ADDC r7, 0

INC r4            ; инкремент пары регистров
INCC r5           ; (можно использовать любой регистр)

CMP  r4, 0xFF     ; сравнение указателя с константой
CMPC r5, 0xFF

CMP  r4, r0       ; сравнение указателей
CMPC r5, r1       ; справа может быть только r0-r4

INV r0            ; r0 := ~r0

MOV  r2, 5        ; r3:r2 := 5
CLR  r3
INV  r2           ; NEG r3:r2
INV  r3
ADD  r2, 1
ADDC r3, 0        ; r3:r2 == -5

RCALL 100         ; вызвать функцию со смещением 100 от текущего адреса
CALL F1           ; вызвать функцию с адресом F1
RJMP 100          ; прыгнуть на 100 команд вперёд

M1:
NOP
RJMP M1

F1:
ADD r0, r1
RET

LOADY r0  ; r0 := RAM[r6:r7]
STOREY r1 ; RAM[r6:r7] := r1

RLOAD r0, [X+1] ; r0 := [r5:r4 + 1]

MOV r3, 10
L1:
; do something
ADD r3, 0xFF
JZ L1
</pre>

</body>
</html>
