<html>
<head>
<style type="text/css">
td {
width: 70;
}

td.mid {
width: 120;
}

td.tact {
width: 175;
}

td.big {
width: 250;
}
</style>
</head>

<body>

<h2>Туду: подумать, куда досыпать светодиодов.</h2>

<h2>Что делаем</h2>
<p>Процессор, точнее МК, на базе 74HC серии, который имеет:</p>
<ul>
<li>8 бит шина данных;</li>
<li>16 бит шина адреса;</li>
<li>3 регистра для доступа к константе, портам ввода и вывода;</li>
<li>8 регистров общего назначения (и ещё 6 таких же теневых);</li>
<li>4 из них могут использоваться для чтения RAM (и 4 теневых);</li>
<li>12 бит размер команды;</li>
<li>51 команда, из них 18 арифметических;</li>
<li>хардварный стек на 8 уровней;</li>
<li>Абсолютная адресация для адреса перехода;</li>
<li>Гарвардская архитектура (ПЗУ команд, ОЗУ данных);</li>
<li>4 такта на команду;</li>
<li>Предельная частота - ? Хорошо, если будет 1МГц!</li>
<li>Изменение выходного пина за 1 команду/4 такта!</li>
</ul>

<h3>Список команд</h3>
<table border=1>
<tr><td colspan=5><h4>Бинарные команды (CTYPE=0)</h4></td></tr>
<tr><td colspan=5>Бинарная команда DST := DST OP SRC</td></tr>
<tr><td>Имя</td><td>COP</td><td class="mid">Операнды</td><td class="big">Описание</td><td>Длина</td></tr>
<tr><td>MUL?</td><td>000</td><td>MUL r0, r1</td><td>Умножение. Результат выполнения ВСЕГДА ложится в соседнюю пару регистров, младший результат в младший регистр, старший в старший, причём используется одна из пар: r1:r0 или r3:r2, ... Пара выбирается по регистру DST.</td><td>1/2</td></tr>
<tr><td>ADD</td><td>001</td><td>ADD r0, r1</td><td>Сложение</td><td>1/2</td></tr>
<tr><td>ADDC</td><td>010</td><td>ADDC r0, r1</td><td>Сложение с переносом</td><td>1/2</td></tr>
<tr><td>AND</td><td>011</td><td>AND r0, r1</td><td>Побитовое И</td><td>1/2</td></tr>
<tr><td>OR</td><td>100</td><td>OR r0, r1</td><td>Побитовое ИЛИ</td><td>1/2</td></tr>
<tr><td>XOR</td><td>101</td><td>XOR r0, r1</td><td>Побитовое Исключающее ИЛИ</td><td>1/2</td></tr>
<tr><td>CMP</td><td>110</td><td>CMP r0, r1</td><td>Сравнение (устанавливает флаги, не портит регистры)</td><td>1/2</td></tr>
<tr><td>CMPC</td><td>111</td><td>CMPC r0, r1</td><td>Сравнение с учётом "переноса": проверяет флаги E/G/L от предыдущей операции</td><td>1/2</td></tr>
<tr><td colspan=5><h4>Унарные команды (CTYPE=1)</h4> DST := OP SRC, по умолчанию DST := OP DST,<br>
например CLR r1, значит то же, что и CLR r1, r1,<br> то же что и r1 := CLR r1.<br>
Пример с NEG лучше: NEG r1 - это то же, что и: r1 := NEG r1<br>
Можно использовать и два регистра: r2 := NEG r1 - или NEG r2, r1</td></tr>
<tr><td>CLR</td><td>000</td><td>CLR r1</td><td>Сброс всех битов</td><td>1</td></tr>
<tr><td>SET</td><td>001</td><td>SET r1</td><td>Установка всех битов регистра в 1</td><td>1</td></tr>
<tr><td>LSL</td><td>010</td><td>LSL r1</td><td>Побитовый сдвиг влево</td><td>1</td></tr>
<tr><td>LSLС</td><td>011</td><td>LSLC r1</td><td>Побитовый сдвиг влево с учётом переноса</td><td>1</td></tr>
<tr><td>LSR</td><td>100</td><td>LSR r1</td><td>Побитовый сдвиг вправо</td><td>1</td></tr>
<tr><td>LSRС</td><td>101</td><td>LSRC r1</td><td>Побитовый сдвиг вправо с учётом переноса</td><td>1</td></tr>
<tr><td>INV</td><td>110</td><td>INV r1</td><td>Побитовая инверсия</td><td>1/2</td></tr>
<tr><td>MOV</td><td>111</td><td>MOV r1, r2</td><td>Копирование из одного регистра в другой</td><td>1/2</td></tr>
<tr><td colspan=5><h4>Дополнительные унарные команды (CTYPE=2)</h4></td></tr>
<tr><td>MIR</td><td>000</td><td>MIR r1</td><td>Зеркальный поворот, СЗР меняется с МЗР</td><td>1</td></tr>
<tr><td>SWAB</td><td>001</td><td>SWAB r1</td><td>Перестановка ниблов местами</td><td>1</td></tr>
<tr><td>[NEG]</td><td>010</td><td>NEG r1</td><td>Изменение знака (инверсия и добавление единицы)</td><td>1</td></tr>
<tr><td>[INC]</td><td>011</td><td>INC r1</td><td>Инкремент. То же, что и ADD r1, 1 но занимает одно слово команды</td><td>1</td></tr>
<tr><td>[DEC]</td><td>100</td><td>DEC r1</td><td>Декремент. То же, что и ADD r1, 0xFF но занимает одно слово команды</td><td>1</td></tr>
<tr><td colspan=5><h4>Условного перехода (CTYPE=3)</h4></td></tr>
<tr><td>JZ</td><td>000</td><td>JZ ADDR</td><td>Переход если флаг Z установлен</td><td>2</td></tr>
<tr><td>JNZ</td><td>001</td><td>JNZ ADDR</td><td>Переход если флаг Z сброшен</td><td>2</td></tr>
<tr><td>JE</td><td>010</td><td>JE ADDR</td><td>Переход если флаг E установлен</td><td>2</td></tr>
<tr><td>JNE</td><td>011</td><td>JNE ADDR</td><td>Переход если флаг E сброшен</td><td>2</td></tr>
<tr><td>JG</td><td>100</td><td>JG ADDR</td><td>Переход если флаг G установлен</td><td>2</td></tr>
<tr><td>JL</td><td>101</td><td>JL ADDR</td><td>Переход если флаг L установлен</td><td>2</td></tr>
<tr><td>JC</td><td>110</td><td>JC ADDR</td><td>Переход если флаг C установлен</td><td>2</td></tr>
<tr><td>JNC</td><td>111</td><td>JNC ADDR</td><td>Переход, если флаг C сброшен</td><td>2</td></tr>
<tr><td>JS</td><td>?</td><td>JS ADDR</td><td>Переход, если флаг S установлен (эта команда не лезет, ибо у дешифратора обычно 8 выходов, а у ИЛИ 8 входов)</td><td>2</td></tr>
<tr><td colspan=5><h4>Безусловного перехода (CTYPE=4)</h4></td></tr>
<tr><td>JMP</td><td>000</td><td>JMP ADDR</td><td>Безусловный переход</td><td>2</td></tr>
<tr><td>CALL</td><td>001</td><td>CALL ADDR</td><td>Вызов функции</td><td>2</td></tr>
<tr><td>RET</td><td>010</td><td>RET</td><td>Возврат из функции</td><td>1</td></tr>
<tr><td>IRET</td><td>011</td><td>IRET</td><td>Возврат из прерывания (разрешает прерывания при выходе)</td><td>1</td></tr>
<tr><td>SIE</td><td>100</td><td>SIE</td><td>SKIP if Equal: пропускает следующую двухсловную команду, если стоит флаг EF. Сравнение не производит, т.к. оно может быть как 1, так и 2-словное.<br>
нужно доработать сумматор адреса, чтобы он выбирал +1/+2/+3 (размер SIE 1, значит можно просто вывод 1 тоже тянуть в 1).</td><td>1</td></tr>
<tr><td>SIZ</td><td>101</td><td>SIZ</td><td>SKIP if Zero (хорошо бы выбрать наиболее подходящий флаг, ибо zero может оказаться не лучшим выбором)</td><td>1</td></tr>
<tr><td>-</td><td>110</td><td>-</td><td>reserved</td><td>1</td></tr>
<tr><td>NOP</td><td>111</td><td>NOP</td><td>No operation</td><td>1</td></tr>
<tr><td colspan=5><h4>Управления (CTYPE=5)</h4></td></tr>
<tr><td>CLRF</td><td>000</td><td>CLRF</td><td>Очистка регистра флагов</td><td>1</td></tr>
<tr><td>DI</td><td>001</td><td>DI</td><td>Disable interrupt</td><td>1</td></tr>
<tr><td>EI</td><td>010</td><td>EI</td><td>Enable interrupt</td><td>1</td></tr>
<tr><td>BANK0</td><td>011</td><td>BANK0</td><td>Connect BANK0 of registers</td><td>1</td></tr>
<tr><td>BANK1</td><td>100</td><td>BANK1</td><td>Connect BANK1 of registers</td><td>1</td></tr>
<tr><td>HALT</td><td>101</td><td>HALT</td><td>Зависнуть!</td><td>1</td></tr>
<tr><td>RESET</td><td>110</td><td>RESET</td><td>Сброс процессора и переход к выполнению кода с нулевого адреса</td><td>1</td></tr>
<tr><td colspan=5><h4>Передачи (CTYPE=6)</h4> Вход RAM подключен к шине A(DST), выход к шине OUT.</td></tr>
<tr><td>LOADX</td><td>000</td><td>LOAD r0</td><td>Загрузка из RAM[r7:r6] в регистр (r0-r3)</td><td>1</td></tr>
<tr><td>STOREX</td><td>001</td><td>STORE r0</td><td>Запись в RAM[r7:r6] указанного регистра (r0-r7)</td><td>1/2</td></tr>
<tr><td>LOADY</td><td>010</td><td>LOAD r0</td><td>Загрузка из RAM[r5:r4] в регистр</td><td>1</td></tr>
<tr><td>STOREY</td><td>011</td><td>STORE r0</td><td>Запись в RAM[r5:r4] указанного регистра</td><td>1/2</td></tr>
<tr><td>RLOAD</td><td>1x0</td><td>RLOAD r0, [X+10]</td><td>Загрузка из RAM[r7:r6 + 10] в регистр (r0-r3)<br>74HC157/74HC151 имеет вход G, который позволяет занулять выходы, а значит можно очень легко суммировать с нулём и менять LOAD <-> RLOAD</td><td>1</td></tr>
<tr><td>RSTORE</td><td>1x1</td><td>RSTORE [Y+10], r0</td><td>Запись в RAM[r5:r4 + 10] указанного регистра (r0-r7)</td><td>1/2</td></tr>
<tr><td colspan=5><h4>Ввода-вывода (CTYPE=7)</h4></td></tr>
<tr><td>IN</td><td>00</td><td>IN r0, PORTx</td><td>Чтение из порта в r0</td><td>1/2</td></tr>
<tr><td>OUT</td><td>001</td><td>OUT PORTx, r0</td><td>Вывод регистра r0 в заданный порт</td><td>1/2</td></tr>
<tr><td>XOUT</td><td>010</td><td>XOUT PORTx, r1</td><td>Вывод регистра r1 XOR r0 в заданный порт (справа может быть любой SRC, включая PORT0)</td><td>1/2</td></tr>
</table>

<i>SIE - Skip If Equal</i>

<p>Длина команды может быть 1 или 2. 2 для случая, когда команда содержит константу.<br>
Константы могут располагаться только по нечётным адресам.<br>
Константы могут быть в любой команде, кроме унарных, CLRF, RET, IRET.<br>
Команда CMP не меняет регистры (только флаги).</p>

<h3>Регистры</h3>
<table border=1>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>r0-r7</td><td>Регистр общего назначения</td></tr>
<tr><td>r7:r6</td><td>Регистр Y адреса ОЗУ</td></tr>
<tr><td>r5:r4</td><td>Регистр X адреса ОЗУ</td></tr>
<tr><td>CONST</td><td>Регистр константы</td></tr>
</table>

<h3>Нумерация регистров</h3>
<table border=1>
<tr><td colspan=2>A(DST)</td><td colspan=2>B(SRC)</td><td class="big">Примечание</td></tr>
<tr><td>r0</td><td>000</td><td>r0</td><td>000</td><td></td></tr>
<tr><td>r1</td><td>001</td><td>r1</td><td>001</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r2</td><td>010</td><td bgcolor="#D5F5E3">r2</td><td>010</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r3</td><td>011</td><td bgcolor="#D5F5E3">r3</td><td>011</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r4</td><td>100</td><td bgcolor="#D5F5E3">r4</td><td>100</td><td></td></tr>
<tr><td bgcolor="#D5F5E3">r5</td><td>101</td><td>PORT0</td><td>101</td><td>Выходной порт 0! Позволяет не запоминать состояние порта и использовать данные порта сразу как операнд.</td></tr>
<tr><td bgcolor="#D5F5E3">r6</td><td>110</td><td>PIN0</td><td>110</td><td>Входной порт 0</td></tr>
<tr><td bgcolor="#D5F5E3">r7</td><td>111</td><td>CONST</td><td>111</td><td>Константа, иногда лежит во втором слове команды</td></tr>
</table>

<p style="background-color:#D5F5E3">Можно переключить на другой банк!</p>

<p>Регистры DST доступны для записи, регистры SRC доступны для чтения. В старшие регистры r5-r7 можно писать, но, нельзя читать. Однако, они могут участвовать в арифметических операциях! И в CMP тоже! r6-r7 подключены к шине адреса ОЗУ.</p>

<h3>Порты</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>PORT0-7</td><td>Порт вывода 0-7, доступен через команду OUT, частично доступен через арифметические команды</td></tr>
<tr><td>PIN0-7</td><td>Порт ввода 0-7, доступен через команду IN, частично доступен через арифметические команды</td></tr>
</table>

<h3>Шины</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>A</td><td>Шина A - это выход мультиплексора по регистрам DST, <b>вход для RAM</b> (то есть, STORE может сохранять любые регистры)</td></tr>
<tr><td>B</td><td>Шина B - это выход мультиплексора по регистрам SRC, вход для унарных команд</td></tr>
<tr><td>OUT</td><td>Шина OUT - это, фактически, выход АЛУ, то есть выход унарных и бинарных команд</td></tr>
</table>

<h3>Структура</h3>
<img src="CPU.png" />

<h3>Регистр флагов</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>ZF (zero flag)</td><td>устанавливается после выполнения любой арифметической операции, если результат операции ноль</td></tr>
<tr><td>CF (carry flag)</td><td>устанавливается после выполнения сложения, если случился перенос</td></tr>
<tr><td>E/G/L (equal/great/less)</td><td>устанавливается после выполнения операции CMP</td></tr>
<tr><td>SF (shift flag)</td><td>устанавливается после выполнения сдвига, если логическая 1 вышла за пределы регистра</td></tr>
</table>

<h3>Значение селектора</h3>
<table border=1 width=250>
<tr><td>SEL</td><td>Адрес следующей инструкции берётся из:</td></tr>
<tr><td>00</td><td>сумматора (+1|+2)</td></tr>
<tr><td>01</td><td>константы адреса</td></tr>
<tr><td>10</td><td>стека</td></tr>
<tr><td>11</td><td>внешнего источника (IRQ)</td></tr>
</table>

<p>Селектор анализируется только если CTYPE == 1, то есть имеет смысл только для команд перехода. Ибо зачем нужен селектор, если после команды сложения обычно нужно просто выполнить следующую команду?</p>

<p>Вообще-то селектор не нужно хранить в команде, ибо сама команда и определяет селектор. Для арифметической команды SEL=0, для команды RET SEL=3, для прерывания, которое вообще не команда, SEL=2. Все команды перехода имеют SEL=1, то есть абсолютную адресацию. Если конечно переход случится!</p>

<h3>Структура арифметической команды</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE == 0</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC)</td></tr>
</table>

<p>или</p>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE == 0</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC) == 100</td></tr>
<tr><td colspan=12>CONST</td></tr>
</table>

<h3>Переходы</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td>-</td><td>-</td><td colspan=4>CONST[15:12]</td></tr>
<tr><td colspan=3>011|100</td><td colspan=3>JMP, Jx, CALL</td><td>-</td><td>-</td><td colspan=4>const higher bits</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Биты 0-3 можно использовать как недостающие. Вместе с 12 бит константой они дадут полный 16 битный адрес.</p>
<br>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>011|100</td><td colspan=3>SIE</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>
<br>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>011|100</td><td colspan=3>RET, IRET</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>

<h3>Управления</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>-</td><td colspan=3>-</td></tr>
<tr><td colspan=3>101</td><td colspan=3>CLRF, NOP, EI, DI</td><td colspan=3>-</td><td colspan=3>-</td></tr>
</table>
<br>

<h3>LOAD</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>-</td></tr>
<tr><td colspan=3>110</td><td colspan=3>LOAD</td><td colspan=3>Rx</td><td colspan=3>-</td></tr>
</table>

<h3>STORE</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>-</td></tr>
<tr><td colspan=3>110</td><td colspan=3>STORE</td><td colspan=3>Rx</td><td colspan=3></td></tr>
</table>
<p>Вход RAM подключен (намертво припаян) к мультиплексору DST, поэтому здесь именно DST, а не SRC.</p>

<h3>IN</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>A(DST)</td><td colspan=3>ADDR</td></tr>
<tr><td colspan=3>111</td><td colspan=3>IN</td><td colspan=3>r0-r7</td><td colspan=3>3 бита</td></tr>
</table>
<p>Адрес порта (0-7), из которого надо произвести чтение</p>

<h3>[X]OUT</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>ADDR</td><td colspan=3>B(SRC)</td></tr>
<tr><td colspan=3>111</td><td colspan=3>OUT</td><td colspan=3>3 бита</td><td colspan=3>r0-r4, CONST, PIN0, PORT0</td></tr>
</table>
<p>Адрес порта (0-7), в который надо произвести запись (пока PORT0-7)</p>

<p>или</p>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=3>CTYPE</td><td colspan=3>COP</td><td colspan=3>ADDR</td><td colspan=3>B(SRC) == 100</td></tr>
<tr><td colspan=3>111</td><td colspan=3>OUT</td><td colspan=3>3 бита</td><td colspan=3>CONST</td></tr>
<tr><td colspan=4>CONST[11:8] - старшие 4 бита адреса</td><td colspan=8>CONST[7:0] - значение</td></tr>
</table>

<p>во втором варианте получается 128 портов</p>

<h3>Примеры команд</h3>
<pre>
MOV r0, r1    ; r0 := r1
ADD r0, r1    ; r0 += r1
AND r3, CONST ; r3 &= CONST
MOV r7, r1    ; r7 := r1
OR r7, CONST  ; r7 |= CONST
MOV r2, PIN0  ; r2 := PIN0  == in

OUT PORT1, r1 ; PORT1 := r1
OUT PORT1, CONST ; PORT1 := CONST

MOV r3, CONST ; r3:= CONST
AND r3, PIN0  ; r3 = r3 & PIN0

MOV r3, r7    ; ошибка! r7 нельзя просто прочитать

ADD r6, 1     ; инкремент пары регистров
ADDC r7, 0

NEG r0        ; r0 := ~r0
NEG r0, r1    ; r0 := ~r1
NEG r0, PIN1  ; r0 := ~PIN1

CALL F1       ; вызвать функцию со смещением F1

M1:
NOP
JMP M1

F1:
ADD r0, r1
RET

LOAD r0  ; r0 := RAM[r6:r7]
STORE r1 ; RAM[r6:r7] := r1

MOV r3, 10
L1:
; do something
ADD r3, 255
JZ L1
</pre>

<h3>Выполнение команды JMP/Jx</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL]<br>0|1 в зависимости от результатов проверки флагов</td><td></td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды SIE (JE через одну следующую команду)</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|3, 3 если EF, 1 если not EF</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td></td><td></td><td></td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды CALL</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2<br>следующая за CALL команда</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0|1</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td></td><td>Push Addr<br>(сумматора, не мультиплексора)</td><td>SP++ (такой необычный стек)</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды RET</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1<br>будет потерян, ибо после RET ничего не выполняется</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>SP--</td><td>Pop Addr<br>(просто читаем вершину стека)</td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 3?</td><td>в этот момент адрес доедет из стека до мультиплексора</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение арифметической команды</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td>(выход команды подключается к шине OUT)</td><td>вычисляет</td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды IN</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>IN</td><td>(выход регистра подключается к шине OUT)<br>Latch PINx</td><td></td><td>Latch r0-r7</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды [X]OUT</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td>(выход команды подключается к шине OUT)</td><td>вычисляет<br>(команду XOR/MOV)</td><td>Latch IR</td><td>Latch PORTx</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды LOAD</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td></td><td>CS = 1</td><td>RD = 1<br>RAM соединён с шиной OUT<br>Latch r0-r7</td><td>CS = 0, RD = 0</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды STORE</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>RAM</td><td>Вход RAM подключен к DST</td><td>CS = 1</td><td>WR = 1</td><td>CS = 0, WR = 0</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение IRQ (формально это не команда, но процесс ложится на наши 4 такта)</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>Логика прерываний</td><td>if (CTYPE==1|3??) T1 := 1</td><td>if (T1) T2 := 1<br>if (T2) Push Next Addr</td><td>-</td><td>if (T2) Latch IRQ Addr</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td>пока выполняется арифметическая команда</td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>Push Addr<br>(сумматора, не мультиплексора). Стек должен быть на 573, чтобы изменяющийся сумматор таки попал в него!</td><td>SP++ (такой необычный стек)</td><td></td></tr>
<tr><td>АЛУ</td><td></td><td></td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td>MUX <= COP[SEL] = 2<br>передумали ;)</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Порядок сборки модулей</h3>
<table border=1>
<tr><td>Модуль</td><td class="big">Что нужно для сборки</td><td>Корпусов</td></tr>
<tr><td>AND</td><td>74HC08*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>ADD/ADDC</td><td>74HC283*2, 74HC08, 74HC573 увы в DIP</td><td>4</td></tr>
<tr><td>MOV</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>ADD Flag</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CMP Flags</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CMP/CMPC</td><td>74HC85*2, 74HC08, лучше в SO</td><td>3</td></tr>
<tr><td>RW Reg, Bank0</td><td>74HC573*8, 74HC238, LEDs</td><td>9</td></tr>
<tr><td>ALU</td><td>74HC245*2, 74HC138*2, stripboard</td><td>4</td></tr>
<tr><td>RW Reg, Bank1</td><td>74HC573*8, 74HC238, LEDs</td><td>9</td></tr>
<tr><td>CLR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSL</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>INV</td><td>74HC00*2, 74HC573, SO</td><td>3</td></tr>
<tr><td>OR</td><td>74HC32*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>XOR</td><td>74HC86*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>SET</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>OUT</td><td>74HC573*4, 74HC238</td><td>5</td></tr>
<tr><td>ADDR counter</td><td>74HC283*4, 74HC273*2, 74HC04</td><td>7</td></tr>
<tr><td>ADDR LED</td><td>GAL16*4, 7 seg LED*4</td><td>4</td></tr>
<tr><td>ROM</td><td>W27C512*3, 74HC573*3, 74HC157*3</td><td>9</td></tr>
<tr><td>ADDR MUX</td><td>74HC153*8</td><td>8</td></tr>
<tr><td>OSC</td><td>74HC04, 74HC161, 74HC139, 74HC00</td><td>4</td></tr>
<tr><td>RAM</td><td>UT62256*2, 74HC573*2, 74HC00</td><td>5</td></tr>
<tr><td>STACK</td><td>74HC573*16, SO, 74HC193, 74HC238</td><td>18</td></tr>
<tr><td>IN</td><td>74HC573, ?</td><td>1</td></tr>
<tr><td>Jump Logic</td><td>74HC238, 74HC08*2, 74HC4078</td><td>4</td></tr>
<tr><td>Interrupt Logic</td><td>74HC00*3, 74HC21 (или 74HC20)</td><td>4</td></tr>
<tr><td>CMD decoder</td><td>мелкая логика, которая связывает все предыдущие модули: 74HC21, 74HC139, ...</td><td>3+</td></tr>
<tr><td>MUL</td><td>74HC283*16, 74HC08*16, 74HC573*2</td><td>34!</td></tr>
<tr><td>MIR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>SWAB</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>Timer ;)</td><td>74HC193*4, 74HC573*2, 74HC00, ... считает в минус, загружается сам</td><td>7</td></tr>
<tr><td colspan=3>Итого - 170 корпусов</td></tr>
</table>

</body>
</html>
