<html>
<head>
<style type="text/css">
td {
width: 70;
}

td.mid {
width: 120;
}

td.tact {
width: 175;
}

td.big {
width: 250;
}
</style>
</head>

<body>

<h2>Туду: подумать, куда досыпать светодиодов.<br>
Сделать индикатор адреса в восьмиричной системе, ибо 74HC4511 не умеет нормально в шестнадцатиричную!<br>
Вход 1 мультиплексора можно подключить к паре регистров, тогда можно сделать ICALL! Но сломается абсолютная адресация :(</h2>

<h2>Что делаем</h2>
<p>Процессор, точнее МК, на базе 74HC серии, который имеет:</p>
<ul>
<li>8 бит шина данных;</li>
<li>16 бит шина адреса;</li>
<li>4 регистра для доступа к константе, портам ввода и вывода;</li>
<li>8 регистров общего назначения;</li>
<li>2 из них могут использоваться для чтения RAM;</li>
<li>12 бит размер команды;</li>
<li>16 арифметических команд и 20 команд управления;</li>
<li>хардварный стек на 8 уровней;</li>
<li>Абсолютная адресация для адреса перехода;</li>
<li>Гарвардская архитектура (ПЗУ команд, ОЗУ данных);</li>
<li>4 такта на команду;</li>
<li>Предельная частота - ? Хорошо, если будет 1МГц!</li>
<li>Изменение выходного пина за 1 команду/4 такта!</li>
</ul>

<h3>Список команд</h3>
<table border=1>
<tr><td colspan=5><h4>Арифметические (CTYPE=0)</h4></td></tr>
<tr><td colspan=5>Бинарная команда DST := DST OP SRC</td></tr>
<tr><td>Имя</td><td>COP</td><td class="mid">Операнды</td><td class="big">Описание</td><td>Длина</td></tr>
<tr><td>AND</td><td>0000</td><td>AND r0, r1</td><td>Побитовое И</td><td>1/2</td></tr>
<tr><td>OR</td><td>0001</td><td>OR r0, r1</td><td>Побитовое ИЛИ</td><td>1/2</td></tr>
<tr><td>XOR</td><td>0010</td><td>XOR r0, r1</td><td>Побитовое Исключающее ИЛИ</td><td>1/2</td></tr>
<tr><td>MUL?</td><td>0011</td><td>MUL r0, r1</td><td>-</td><td>1/2</td></tr>
<tr><td>ADD</td><td>0100</td><td>ADD r0, r1</td><td>Сложение</td><td>1/2</td></tr>
<tr><td>ADDC</td><td>0101</td><td>ADDC r0, r1</td><td>Сложение с переносом</td><td>1/2</td></tr>
<tr><td>CMP</td><td>0110</td><td>CMP r0, r1</td><td>Сравнение (устанавливает флаги, не портит регистры)</td><td>1/2</td></tr>
<tr><td>CMPC</td><td>0111</td><td>CMPC r0, r1</td><td>Сравнение с учётом "переноса": проверяет флаги E/G/L от предыдущей операции</td><td>1/2</td></tr>
<tr><td colspan=5>Унарные команды DST := OP SRC, по умолчанию DST := OP DST,<br>
например CLR r1, значит то же, что и CLR r1, r1,<br> то же что и r1 := CLR r1.<br>
Пример с NEG лучше: NEG r1 - это то же, что и: r1 := NEG r1<br>
Можно использовать и два регистра: r2 := NEG r1 - или NEG r2, r1</td></tr>
<tr><td>CLR</td><td>1000</td><td>CLR r1</td><td>Сброс всех битов</td><td>1</td></tr>
<tr><td>INV</td><td>1001</td><td>NEG r1</td><td>Побитовая инверсия</td><td>1/2</td></tr>
<tr><td>LSL</td><td>1010</td><td>LSL r1</td><td>Побитовый сдвиг влево</td><td>1</td></tr>
<tr><td>LSR</td><td>1011</td><td>LSR r1</td><td>Побитовый сдвиг вправо</td><td>1</td></tr>
<tr><td>MIR</td><td>1100</td><td>MIR r1</td><td>Зеркальный поворот, СЗР меняется с МЗР</td><td>1</td></tr>
<tr><td>MOV</td><td>1101</td><td>MOV r1, r2</td><td>Копирование из одного регистра в другой</td><td>1/2</td></tr>
<tr><td>SWAB</td><td>1110</td><td>SWAB r1</td><td>Перестановка ниблов местами</td><td>1</td></tr>
<tr><td>SET</td><td>1111</td><td>SET r1</td><td>Установка всех битов регистра в 1</td><td>1</td></tr>
<tr><td colspan=5><h4>Перехода (CTYPE=1)</h4></td></tr>
<tr><td>JZ</td><td>0000</td><td>JZ ADDR</td><td>Переход если флаг Z установлен</td><td>2</td></tr>
<tr><td>JNZ</td><td>0001</td><td>JNZ ADDR</td><td>Переход если флаг Z сброшен</td><td>2</td></tr>
<tr><td>JE</td><td>0010</td><td>JE ADDR</td><td>Переход если флаг E установлен</td><td>2</td></tr>
<tr><td>JG</td><td>0011</td><td>JG ADDR</td><td>Переход если флаг G установлен</td><td>2</td></tr>
<tr><td>JL</td><td>0100</td><td>JL ADDR</td><td>Переход если флаг L установлен</td><td>2</td></tr>
<tr><td>JC</td><td>0101</td><td>JC ADDR</td><td>Переход если флаг C установлен</td><td>2</td></tr>
<tr><td>JNC</td><td>0110</td><td>JNC ADDR</td><td>Переход, если флаг C сброшен</td><td>2</td></tr>
<tr><td>JS</td><td>0111</td><td>JS ADDR</td><td>Переход, если флаг S установлен</td><td>2</td></tr>
<tr><td>JMP</td><td>1000</td><td>JMP ADDR</td><td>Безусловный переход</td><td>2</td></tr>
<tr><td>CALL</td><td>1001</td><td>CALL ADDR</td><td>Вызов функции</td><td>2</td></tr>
<tr><td>RET</td><td>1010</td><td>RET</td><td>Возврат из функции</td><td>1</td></tr>
<tr><td>IRET</td><td>1011</td><td>IRET</td><td>Возврат из прерывания (разрешает прерывания при выходе)</td><td>1</td></tr>
<tr><td>CSIE</td><td>1100</td><td>СSIE</td><td>SKIP if Equal: пропускает следующую двухсловную команду, если стоит флаг EF (как тебе такое, Атмел?)<br>
нужно доработать сумматор адреса, чтобы он выбирал +1/+2/+3 (размер CSPE 1, значит можно просто вывод 1 тоже тянуть в 1).</td><td>1</td></tr>
<tr><td colspan=5><h4>Управления (CTYPE=2)</h4></td></tr>
<tr><td>CLRF</td><td>0000</td><td>CLRF</td><td>Очистка регистра флагов</td><td>1</td></tr>
<tr><td>NOP</td><td>0001</td><td>NOP</td><td>No operation</td><td>1</td></tr>
<tr><td>DI</td><td>0010</td><td>DI</td><td>Disable interrupt</td><td>1</td></tr>
<tr><td>EI</td><td>0011</td><td>EI</td><td>Enable interrupt</td><td>1</td></tr>
<tr><td>RESET</td><td>0100</td><td>RESET</td><td>Сброс процессора и переход к выполнению кода с нулевого адреса</td><td>1</td></tr>
<tr><td colspan=5><h4>Передачи (CTYPE=3)</h4></td></tr>
<tr><td>LOAD</td><td>0000</td><td>LOAD r0</td><td>Загрузка из RAM[r7:r6] в регистр</td><td>1</td></tr>
<tr><td>STORE</td><td>0001</td><td>STORE r0</td><td>Запись в RAM[r7:r6] указанного регистра</td><td>1/2</td></tr>
<tr><td>IN</td><td>0010</td><td>IN r0, PORTx</td><td>Чтение из порта в r0 (требует доработки логики АЛУ)</td><td>1</td></tr>
<tr><td>OUT</td><td>0011</td><td>OUT PORTx, r0</td><td>Вывод регистра r0 в заданный порт</td><td>1/2</td></tr>
<tr><td>XOUT</td><td>0100</td><td>XOUT PORTx, r1</td><td>Вывод регистра r1 XOR r0 в заданный порт (справа может быть любой SRC, включая PORT0)</td><td>1/2</td></tr>
<tr><td>CFG</td><td>0101</td><td>CFG ADDR, r0</td><td>Вывод регистра r0 в регистр конфигурации. По сути, это OUT, но к данному адресному пространству будут подключены устройства, которые надо конфигурировать. Таймер, ... Константа в данном случае используется как адрес, поэтому в качестве SRC может быть только какой-то регистр, но не константа. Пичалька.</td><td>2</td></tr>
</table>

<i>CSIE - Compare Skip If Equal</i>

<p>Длина команды может быть 1 или 2. 2 для случая, когда команда содержит константу.<br>
Константы могут располагаться только по нечётным адресам.<br>
Константы могут быть в любой команде, кроме унарных, CLRF, RET, IRET.<br>
Команда CMP не меняет регистры (только флаги).</p>

<h3>Структура арифметической команды</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 0</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC)</td><td colspan=4>COP</td></tr>
</table>

<p>или</p>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 0</td><td colspan=3>A(DST)</td><td colspan=3>B(SRC) == 100</td><td colspan=4>COP</td></tr>
<tr><td colspan=12>CONST</td></tr>
</table>

<h3>Регистры</h3>
<table border=1 width=250>
<tr><td>Имя</td><td>Назначение</td></tr>
<tr><td>r0-r7</td><td>Регистр общего назначения</td></tr>
<tr><td>r7:r6</td><td>Регистр адреса ОЗУ</td></tr>
<tr><td>CONST</td><td>Регистр константы</td></tr>
</table>

<h3>Нумерация регистров</h3>
<table border=1>
<tr><td colspan=2>A(DST)</td><td colspan=2>B(SRC)</td><td class="big">Примечание</td></tr>
<tr><td>r0</td><td>000</td><td>r0</td><td>000</td><td></td></tr>
<tr><td>r1</td><td>001</td><td>r1</td><td>001</td><td></td></tr>
<tr><td>r2</td><td>010</td><td>r2</td><td>010</td><td></td></tr>
<tr><td>r3</td><td>011</td><td>r3</td><td>011</td><td></td></tr>
<tr><td>r4</td><td>100</td><td>CONST</td><td>100</td><td>Константа, иногда лежит во втором слове команды</td></tr>
<tr><td>r5</td><td>101</td><td>PIN0</td><td>101</td><td>Входной порт 0</td></tr>
<tr><td>r6</td><td>110</td><td>PIN1</td><td>110</td><td>Входной порт 1</td></tr>
<tr><td>r7</td><td>111</td><td>PORT0</td><td>111</td><td>Выходной порт 0! Позволяет сэкономить на команде IN и использовать данные порта сразу как операнд.</td></tr>
</table>

<p>Регистры DST доступны для записи, регистры SRC доступны для чтения. В старшие регистры r4-r7 можно писать, но, нельзя читать. Однако, они могут участвовать в арифметических операциях! И в CMP тоже! r6-r7 подключены к шине адреса ОЗУ.</p>

<h3>Порты</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>PORT0-7</td><td>Порт вывода 0-7, доступен через команду OUT, частично доступен через арифметические команды</td></tr>
<tr><td>PIN0-7</td><td>Порт ввода 0-7, доступен через команду IN, частично доступен через арифметические команды</td></tr>
</table>

<h3>Шины</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>A</td><td>Шина A - это выход мультиплексора по регистрам DST</td></tr>
<tr><td>B</td><td>Шина B - это выход мультиплексора по регистрам SRC, вход для унарных команд</td></tr>
<tr><td>OUT</td><td>Шина OUT - это, фактически, выход АЛУ, то есть выход унарных и бинарных команд</td></tr>
</table>

<h3>Регистр флагов</h3>
<table border=1 width=400>
<tr><td>Имя</td><td class="big">Назначение</td></tr>
<tr><td>ZF (zero flag)</td><td>устанавливается после выполнения любой арифметической операции, если результат операции ноль</td></tr>
<tr><td>CF (carry flag)</td><td>устанавливается после выполнения сложения, если случился перенос</td></tr>
<tr><td>E/G/L (equal/great/less)</td><td>устанавливается после выполнения операции CMP</td></tr>
<tr><td>SF (shift flag)</td><td>устанавливается после выполнения сдвига, если логическая 1 вышла за пределы регистра</td></tr>
</table>

<h3>Значение селектора</h3>
<table border=1 width=250>
<tr><td>SEL</td><td>Адрес следующей инструкции берётся из:</td></tr>
<tr><td>00</td><td>сумматора (+1|+2)</td></tr>
<tr><td>01</td><td>константы адреса</td></tr>
<tr><td>10</td><td>стека</td></tr>
<tr><td>11</td><td>внешнего источника (IRQ)</td></tr>
</table>

<p>Селектор анализируется только если CTYPE == 1, то есть имеет смысл только для команд перехода. Ибо зачем нужен селектор, если после команды сложения обычно нужно просто выполнить следующую команду?</p>

<p>Вообще-то селектор не нужно хранить в команде, ибо сама команда и определяет селектор. Для арифметической команды SEL=0, для команды RET SEL=3, для прерывания, которое вообще не команда, SEL=2. Все команды перехода имеют SEL=1, то есть абсолютную адресацию. Если конечно переход случится!</p>

<h3>Переходы</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 1</td><td colspan=4>CONST[15:12]</td><td>-</td><td>-</td><td colspan=4>COP</td></tr>
<tr><td>0</td><td>1</td><td colspan=4>const higher bits</td><td>-</td><td>-</td><td colspan=4>JMP, Jx, CALL</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Биты 6-9 можно использовать как недостающие. Вместе с 12 бит константой они дадут полный 16 битный адрес.</p>
<br>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 1</td><td colspan=3>-</td><td colspan=3>-</td><td colspan=4>COP</td></tr>
<tr><td>0</td><td>1</td><td colspan=3>-</td><td colspan=3>-</td><td colspan=4>RET, IRET</td></tr>
</table>

<h3>Управления</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 2</td><td colspan=3>-</td><td colspan=3>-</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>0</td><td colspan=3>-</td><td colspan=3>-</td><td colspan=4>CLRF, NOP, EI, DI</td></tr>
</table>
<br>

<h3>LOAD</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>A(DST)</td><td colspan=3>-</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>1</td><td colspan=3>Rx</td><td colspan=3>-</td><td colspan=4>LOAD</td></tr>
</table>

<h3>STORE</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>-</td><td colspan=3>B(SRC)</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>1</td><td colspan=3>-</td><td colspan=3>Rx</td><td colspan=4>STORE</td></tr>
<tr><td colspan=12>CONST[7:0] - опционально, только для SRC==100</td></tr>
</table>

<h3>IN</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>A(DST)</td><td colspan=3>ADDR</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>1</td><td colspan=3>r0-r7</td><td colspan=3>3 бита</td><td colspan=4>IN</td></tr>
</table>
<p>Адрес порта (0-7), из которого надо произвести чтение</p>

<h3>[X]OUT</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>ADDR</td><td colspan=3>B(SRC)</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>1</td><td colspan=3>3 бита</td><td colspan=3>r0-r3, PORT0, PIN0, PIN1</td><td colspan=4>OUT</td></tr>
</table>
<p>Адрес порта (0-7), в который надо произвести запись (пока PORT0-7)</p>

<p>или</p>

<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>ADDR</td><td colspan=3>B(SRC) == 100</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>1</td><td colspan=3>3 бита</td><td colspan=3>CONST</td><td colspan=4>OUT</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>

<h3>CFG</h3>
<table border=1>
<tr><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
<tr><td colspan=2>CTYPE == 3</td><td colspan=3>reserved</td><td colspan=3>B(SRC)</td><td colspan=4>COP</td></tr>
<tr><td>1</td><td>0</td><td colspan=3>reserved</td><td colspan=3>r0-r3, PORT0, PIN0, PIN1</td><td colspan=4>CFG</td></tr>
<tr><td colspan=12>CONST[11:0]</td></tr>
</table>
<p>Биты 7-9 можно использовать как недостающие. Пока адрес будет 12 битный == 4096 регистров конфигурации ;))<br>
В константе хранится адрес, поэтому SRC=100 (CFG 123, CONST) не допустим.</p>
<br>

<h3>Примеры команд</h3>
<pre>
MOV r0, r1    ; r0 := r1
ADD r0, r1    ; r0 += r1
AND r3, CONST ; r3 &= CONST
MOV r7, r1    ; r7 := r1
OR r7, CONST  ; r7 |= CONST
MOV r2, PIN0  ; r2 := PIN0  == in

OUT PORT1, r1 ; PORT1 := r1
OUT PORT1, CONST ; PORT1 := CONST

MOV r3, CONST ; r3:= CONST
AND r3, PIN0  ; r3 = r3 & PIN0

MOV r3, r7    ; ошибка! r7 нельзя просто прочитать

ADD r6, 1     ; инкремент пары регистров
ADDC r7, 0

NEG r0        ; r0 := ~r0
NEG r0, r1    ; r0 := ~r1
NEG r0, PIN1  ; r0 := ~PIN1

CALL F1       ; вызвать функцию со смещением F1

M1:
NOP
JMP M1

F1:
ADD r0, r1
RET

LOAD r0  ; r0 := RAM[r6:r7]
STORE r1 ; RAM[r6:r7] := r1

MOV r3, 10
L1:
; do something
ADD r3, 255
JZ L1
</pre>

<h3>Выполнение команды JMP/Jx</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL]<br>0|1 в зависимости от результатов проверки флагов</td><td></td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды CSIE</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td>Addr += (ещё)2<br>передумали, пропускаем след команду ;)</td><td></td></tr>
<tr><td>АЛУ</td><td></td><td>сравнивает</td><td>Latch Flags</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды CALL</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 2<br>следующая за CALL команда</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0|1</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td></td><td>Push Addr<br>(сумматора, не мультиплексора)</td><td>SP++ (такой необычный стек)</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение команды RET</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1<br>будет потерян, ибо после RET ничего не выполняется</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>SP--</td><td>Pop Addr<br>(просто читаем вершину стека)</td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 3?</td><td>в этот момент адрес доедет из стека до мультиплексора</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение арифметической команды</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td></td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td></td><td></td></tr>
<tr><td>АЛУ</td><td></td><td>вычисляет</td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Выполнение IRQ (формально это не команда, но процесс ложится на наши 4 такта)</h3>
<table border=1>
<tr><td class="tact">Модуль</td><td class="tact">Такт 0</td><td class="tact">Такт 1</td><td class="tact">Такт 2</td><td class="tact">Такт 3</td></tr>
<tr><td>Логика прерываний</td><td>if (CTYPE==1|3??) T1 := 1</td><td>if (T1) T2 := 1<br>if (T2) Push Next Addr</td><td>-</td><td>if (T2) Latch IRQ Addr</td></tr>
<tr><td>ROM + Регистр команд</td><td>Latch COP & const</td><td>пока выполняется арифметическая команда</td><td></td><td></td></tr>
<tr><td>Счётчик адреса</td><td></td><td>Addr += 1|2</td><td></td><td></td></tr>
<tr><td>Стек</td><td></td><td>Push Addr<br>(сумматора, не мультиплексора). Стек должен быть на 573, чтобы изменяющийся сумматор таки попал в него!</td><td>SP++ (такой необычный стек)</td><td></td></tr>
<tr><td>АЛУ</td><td></td><td></td><td>Latch IR, Latch Flags</td><td>Latch r0-r7</td></tr>
<tr><td>Мультиплексор адреса</td><td></td><td>MUX <= COP[SEL] = 0</td><td>MUX <= COP[SEL] = 2<br>передумали ;)</td><td></td></tr>
<tr><td>Регистр адреса</td><td></td><td></td><td></td><td>Latch Addr</td></tr>
</table>

<h3>Порядок сборки модулей</h3>
<table border=1>
<tr><td>Модуль</td><td class="big">Что нужно для сборки</td><td>Корпусов</td></tr>
<tr><td>AND</td><td>74HC08*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>OR</td><td>74HC32*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>XOR</td><td>74HC86*2, 74HC573, всё в SO</td><td>3</td></tr>
<tr><td>ADD/ADDC</td><td>74HC283*2, 74HC08, 74HC573 увы в DIP</td><td>4</td></tr>
<tr><td>CMP/CMPC</td><td>74HC85*2, 74HC08, лучше в SO</td><td>3</td></tr>
<tr><td>NEG</td><td>74HC00*2, 74HC573, SO</td><td>3</td></tr>
<tr><td>ALU</td><td>74HC245*2, 74HC138*2, stripboard</td><td>4</td></tr>
<tr><td>MOV</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>ADD Flag</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CMP Flags</td><td>74HC175, 74HC04</td><td>2</td></tr>
<tr><td>CLR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSL</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>LSR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>SET</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>SWAB</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>MIR</td><td>74HC573, SO</td><td>1</td></tr>
<tr><td>RW Reg</td><td>74HC573*8, 74HC238, LEDs</td><td>9</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>MUX1</td><td>74HC151*8</td><td>8</td></tr>
<tr><td>OUT</td><td>74HC573*4, 74HC238</td><td>5</td></tr>
<tr><td>ADDR counter</td><td>74HC283*4, 74HC273*2, 74HC04</td><td>7</td></tr>
<tr><td>ADDR LED</td><td>GAL16*4, 7 seg LED*4</td><td>4</td></tr>
<tr><td>ROM</td><td>W27C512*3, 74HC573*3, 74HC157*3</td><td>9</td></tr>
<tr><td>ADDR MUX</td><td>74HC153*8</td><td>8</td></tr>
<tr><td>OSC</td><td>74HC04, 74HC161, 74HC139, 74HC00</td><td>4</td></tr>
<tr><td>STACK</td><td>74HC573*16, SO, 74HC193, 74HC238</td><td>18</td></tr>
<tr><td>MUL</td><td>74HC283*16, 74HC08*16, 74HC573*2</td><td>34!</td></tr>
<tr><td>IN</td><td>74HC573, ?</td><td>1</td></tr>
<tr><td>Timer ;)</td><td>74HC193*4, 74HC573*2, 74HC00, ... считает в минус, загружается сам</td><td>7</td></tr>
<tr><td>CFG</td><td>74HC238</td><td>1</td></tr>
<tr><td>Interrupt Logic</td><td>74HC00*3, 74HC21 (или 74HC20)</td><td>4</td></tr>
<tr><td>Jump Logic</td><td>74HC238, 74HC08*2, 74HC4078</td><td>4</td></tr>
<tr><td>RAM</td><td>UT62256*2, 74HC573*2, 74HC00</td><td>5</td></tr>
<tr><td>CMD decoder</td><td>мелкая логика, которая связывает все предыдущие модули: 74HC21, 74HC139, ...</td><td>3+</td></tr>
<tr><td colspan=3>Итого - 170 корпусов</td></tr>
</table>

</body>
</html>
